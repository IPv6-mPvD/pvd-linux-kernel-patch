diff -Naur -X DiffNaurExclude ubuntu-4.10.0-orig/drivers/net/Kconfig ubuntu-4.10.0/drivers/net/Kconfig
--- ubuntu-4.10.0-orig/drivers/net/Kconfig	2017-08-10 11:05:24.289046482 +0100
+++ ubuntu-4.10.0/drivers/net/Kconfig	2017-07-18 14:25:07.395522852 +0100
@@ -1,4 +1,21 @@
 #
+# Network Provisioning Domain configuration
+#
+
+menuconfig NETPVD
+	default y if UML
+	depends on NET
+	bool "Network PvD support"
+	---help---
+	  You can say N here if you don't intend to connect your Linux box to
+	  any other computer at all.
+
+	  You'll have to say Y if applications intend to make use of the
+	  provisioning domain feature
+
+	  If unsure, say Y.
+
+#
 # Network device configuration
 #
 
diff -Naur -X DiffNaurExclude ubuntu-4.10.0-orig/include/linux/sched.h ubuntu-4.10.0/include/linux/sched.h
--- ubuntu-4.10.0-orig/include/linux/sched.h	2017-08-10 11:05:24.289046482 +0100
+++ ubuntu-4.10.0/include/linux/sched.h	2017-07-18 14:25:07.395522852 +0100
@@ -2002,6 +2002,10 @@
 	/* A live task holds one reference. */
 	atomic_t stack_refcount;
 #endif
+#ifdef	CONFIG_NET_PVD
+	int			sk_n_bound_pvd;		/* -1 : undefined, #-1 : forcibly set */
+	int			sk_bound_pvds[32];	/* FIXME : use MAXBOUNDPVD instead */
+#endif
 /* CPU-specific state of this task */
 	struct thread_struct thread;
 /*
diff -Naur -X DiffNaurExclude ubuntu-4.10.0-orig/include/net/addrconf.h ubuntu-4.10.0/include/net/addrconf.h
--- ubuntu-4.10.0-orig/include/net/addrconf.h	2017-08-10 11:05:24.289046482 +0100
+++ ubuntu-4.10.0/include/net/addrconf.h	2017-07-18 14:25:07.399522852 +0100
@@ -98,14 +98,16 @@
 void addrconf_leave_solict(struct inet6_dev *idev, const struct in6_addr *addr);
 
 void addrconf_add_linklocal(struct inet6_dev *idev,
-			    const struct in6_addr *addr, u32 flags);
+			    const struct in6_addr *addr, u32 flags,
+			    void *pvd);
 
 int addrconf_prefix_rcv_add_addr(struct net *net, struct net_device *dev,
 				 const struct prefix_info *pinfo,
 				 struct inet6_dev *in6_dev,
 				 const struct in6_addr *addr, int addr_type,
 				 u32 addr_flags, bool sllao, bool tokenized,
-				 __u32 valid_lft, u32 prefered_lft);
+				 __u32 valid_lft, u32 prefered_lft,
+				 void *pvd);
 
 static inline int addrconf_ifid_eui48(u8 *eui, struct net_device *dev)
 {
@@ -242,7 +244,8 @@
 }
 
 void addrconf_prefix_rcv(struct net_device *dev,
-			 u8 *opt, int len, bool sllao);
+			 u8 *opt, int len, bool sllao,
+			 void *pvd);
 
 /*
  *	anycast prototypes (anycast.c)
diff -Naur -X DiffNaurExclude ubuntu-4.10.0-orig/include/net/if_inet6.h ubuntu-4.10.0/include/net/if_inet6.h
--- ubuntu-4.10.0-orig/include/net/if_inet6.h	2017-08-10 11:05:24.289046482 +0100
+++ ubuntu-4.10.0/include/net/if_inet6.h	2017-07-18 14:25:07.399522852 +0100
@@ -41,6 +41,7 @@
 struct inet6_ifaddr {
 	struct in6_addr		addr;
 	__u32			prefix_len;
+	void			*pvd;
 
 	/* In seconds, relative to tstamp. Expiry is at tstamp + HZ * lft. */
 	__u32			valid_lft;
diff -Naur -X DiffNaurExclude ubuntu-4.10.0-orig/include/net/ip6_fib.h ubuntu-4.10.0/include/net/ip6_fib.h
--- ubuntu-4.10.0-orig/include/net/ip6_fib.h	2017-08-10 11:05:24.289046482 +0100
+++ ubuntu-4.10.0/include/net/ip6_fib.h	2017-07-18 14:25:07.399522852 +0100
@@ -53,6 +53,10 @@
 	struct nl_info	fc_nlinfo;
 	struct nlattr	*fc_encap;
 	u16		fc_encap_type;
+
+#ifdef	CONFIG_NETPVD
+	void		*fc_pvd;
+#endif
 };
 
 struct fib6_node {
@@ -133,6 +137,12 @@
 	/* more non-fragment space at head required */
 	unsigned short			rt6i_nfheader_len;
 	u8				rt6i_protocol;
+
+	/*
+	 * TODO : check if adding fields in this structure
+	 * does not trash cache lines (CONFIG_NETPVD)
+	 */
+	void 				*rt6i_pvd;
 };
 
 static inline struct inet6_dev *ip6_dst_idev(struct dst_entry *dst)
diff -Naur -X DiffNaurExclude ubuntu-4.10.0-orig/include/net/ip6_route.h ubuntu-4.10.0/include/net/ip6_route.h
--- ubuntu-4.10.0-orig/include/net/ip6_route.h	2017-08-10 11:05:24.289046482 +0100
+++ ubuntu-4.10.0/include/net/ip6_route.h	2017-07-18 14:25:07.399522852 +0100
@@ -34,6 +34,10 @@
 #define RT6_LOOKUP_F_SRCPREF_COA	0x00000020
 #define RT6_LOOKUP_F_IGNORE_LINKSTATE	0x00000040
 
+#ifdef	CONFIG_NETPVD
+#define	RT6_LOOKUP_F_PVD		0x00000080
+#endif
+
 /* We do not (yet ?) support IPv6 jumbograms (RFC 2675)
  * Unlike IPv4, hdr->seg_len doesn't include the IPv6 header
  */
@@ -90,7 +94,7 @@
 
 int ipv6_route_ioctl(struct net *net, unsigned int cmd, void __user *arg);
 
-int ip6_route_add(struct fib6_config *cfg);
+int ip6_route_add(struct fib6_config *cfg, const char *caller);
 int ip6_ins_rt(struct rt6_info *);
 int ip6_del_rt(struct rt6_info *);
 
@@ -121,7 +125,10 @@
 void fib6_force_start_gc(struct net *net);
 
 struct rt6_info *addrconf_dst_alloc(struct inet6_dev *idev,
-				    const struct in6_addr *addr, bool anycast);
+				    const struct in6_addr *addr,
+				    void *pvd,	/* CONFIG_NETPVD */
+				    bool anycast,
+				    const char *caller);
 
 struct rt6_info *ip6_dst_alloc(struct net *net, struct net_device *dev,
 			       int flags);
@@ -138,7 +145,12 @@
 void rt6_purge_dflt_routers(struct net *net);
 
 int rt6_route_rcv(struct net_device *dev, u8 *opt, int len,
-		  const struct in6_addr *gwaddr);
+		  const struct in6_addr *gwaddr,
+		  void *pvd);	/* CONFIG_NETPVD */
+int ip6_route_pvd_attach(
+		struct sock *sk,
+		char __user *optval,
+		int optlen);
 
 void ip6_update_pmtu(struct sk_buff *skb, struct net *net, __be32 mtu, int oif,
 		     u32 mark, kuid_t uid);
diff -Naur -X DiffNaurExclude ubuntu-4.10.0-orig/include/net/ndisc.h ubuntu-4.10.0/include/net/ndisc.h
--- ubuntu-4.10.0-orig/include/net/ndisc.h	2017-08-10 11:05:24.289046482 +0100
+++ ubuntu-4.10.0/include/net/ndisc.h	2017-07-28 10:37:27.875366305 +0100
@@ -37,6 +37,9 @@
 	ND_OPT_RDNSS = 25,		/* RFC5006 */
 	ND_OPT_DNSSL = 31,		/* RFC6106 */
 	ND_OPT_6CO = 34,		/* RFC6775 */
+#ifdef	CONFIG_NETPVD
+	ND_OPT_PVDID = 253,		/* DRAFT : 253 this will waste space */
+#endif
 	__ND_OPT_MAX
 };
 
@@ -52,6 +55,9 @@
 #include <linux/if_arp.h>
 #include <linux/netdevice.h>
 #include <linux/hash.h>
+#ifdef	CONFIG_NETPVD
+#include <net/pvd.h>
+#endif
 
 #include <net/neighbour.h>
 
@@ -102,6 +108,14 @@
 	__u8		nd_opt_len;
 } __packed;
 
+struct nd_opt_pvdid {
+	uint8_t nd_opt_pvdid_type;
+	uint8_t nd_opt_pvdid_len;
+	uint16_t nd_opt_pvdid_flags;
+	uint16_t nd_opt_pvdid_sequence_number;
+	unsigned char nd_opt_pvdid_name[];
+};
+
 /* ND options */
 struct ndisc_options {
 	struct nd_opt_hdr *nd_opt_array[__ND_OPT_ARRAY_MAX];
@@ -114,6 +128,13 @@
 #if IS_ENABLED(CONFIG_IEEE802154_6LOWPAN)
 	struct nd_opt_hdr *nd_802154_opt_array[ND_OPT_TARGET_LL_ADDR + 1];
 #endif
+#ifdef	CONFIG_NETPVD
+	struct nd_opt_hdr *nd_opt_pvdid;
+	char pvdname[PVDNAMSIZ];
+	int pvd_sequence_number;
+	int pvd_h_flag;
+	int pvd_l_flag;
+#endif
 };
 
 #define nd_opts_src_lladdr		nd_opt_array[ND_OPT_SOURCE_LL_ADDR]
@@ -215,7 +236,8 @@
 				       int addr_type, u32 addr_flags,
 				       bool sllao, bool tokenized,
 				       __u32 valid_lft, u32 prefered_lft,
-				       bool dev_addr_generated);
+				       bool dev_addr_generated,
+				       void *pvd);
 };
 
 #if IS_ENABLED(CONFIG_IPV6)
@@ -295,7 +317,8 @@
 						 bool sllao, bool tokenized,
 						 __u32 valid_lft,
 						 u32 prefered_lft,
-						 bool dev_addr_generated)
+						 bool dev_addr_generated,
+						 void *pvd)
 {
 	if (dev->ndisc_ops && dev->ndisc_ops->prefix_rcv_add_addr)
 		dev->ndisc_ops->prefix_rcv_add_addr(net, dev, pinfo, in6_dev,
@@ -303,7 +326,8 @@
 						    addr_flags, sllao,
 						    tokenized, valid_lft,
 						    prefered_lft,
-						    dev_addr_generated);
+						    dev_addr_generated,
+						    pvd);
 }
 #endif
 
diff -Naur -X DiffNaurExclude ubuntu-4.10.0-orig/include/net/net_namespace.h ubuntu-4.10.0/include/net/net_namespace.h
--- ubuntu-4.10.0-orig/include/net/net_namespace.h	2017-08-10 11:05:24.289046482 +0100
+++ ubuntu-4.10.0/include/net/net_namespace.h	2017-07-18 14:25:07.403522851 +0100
@@ -39,11 +39,16 @@
 struct net_generic;
 struct sock;
 struct netns_ipvs;
+struct pvd;	/* anonymous */
 
 
 #define NETDEV_HASHBITS    8
 #define NETDEV_HASHENTRIES (1 << NETDEV_HASHBITS)
 
+#ifdef	CONFIG_NETPVD
+#include <linux/pvd-user.h>
+#endif
+
 struct net {
 	atomic_t		passive;	/* To decided when the network
 						 * namespace should be freed.
@@ -83,6 +88,42 @@
 	int			ifindex;
 	unsigned int		dev_unreg_count;
 
+#ifdef	CONFIG_NETPVD
+	/*
+	 * Pvd related info
+	 * pvdindex : sequence number used to allocate a unique
+	 * number to each pvd
+	 *
+	 * pvd_free_slots[] is a linked list of indexes (each cell
+	 * contains the index of the next free pvd slot). first_free_pvd_ix
+	 * is the index of the first free slot (-1 means no more slots)
+	 *
+	 * pvd_used_slots[] is an array of pointer to active pvd
+	 * structures. The pvd structures are linked together via
+	 * a next field. first_used_pvd points to the head of the
+	 * pvd current list. The pvd_used_slots[] is used to perform
+	 * consistency checks on pvds, and not (for now) to list
+	 * them
+	 *
+	 * If a slot is not part of the pvd_free_slots[] list,
+	 * then its pvd_used_slots[] entry points to a pvd
+	 */
+	unsigned int		pvd_base_seq;	/* protected by rtnl_mutex */
+	u32			pvdindex;
+	void			*pvd_used_slots[MAXPVD];/* struct net_pvd *[] */
+	void			*first_used_pvd;	/* struct net_pvd * */
+	int			pvd_free_slots[MAXPVD];	/* array of indexes */
+	int			first_free_pvd_ix;	/* index */
+	unsigned int		pvd_unreg_count;
+
+	void			*pvd_cached_ra;
+
+	struct timer_list	pvd_timer;
+#ifdef CONFIG_PROC_FS
+	struct proc_dir_entry	*proc_pvdd;
+#endif
+#endif	/* CONFIG_NETPVD */
+
 	/* core fib_rules */
 	struct list_head	rules_ops;
 
diff -Naur -X DiffNaurExclude ubuntu-4.10.0-orig/include/net/pvd.h ubuntu-4.10.0/include/net/pvd.h
--- ubuntu-4.10.0-orig/include/net/pvd.h	1970-01-01 01:00:00.000000000 +0100
+++ ubuntu-4.10.0/include/net/pvd.h	2017-07-28 16:35:29.255470129 +0100
@@ -0,0 +1,207 @@
+
+#ifndef	_NET_PVD_H
+#define	_NET_PVD_H
+
+#ifdef	CONFIG_NETPVD
+
+#include <net/net_namespace.h>
+#include <linux/percpu.h>
+#include <linux/hash.h>
+#include <linux/list.h>
+#include <linux/rculist.h>
+
+#include <linux/pvd-user.h>
+
+/*
+ * In the net_pvd structure below, the pvdindex and
+ * _index fields may be combined to form a full index
+ * The full index, in turn, can be used to check a
+ * pvd handle consistency/validity. Socket bound to
+ * a set of pvds are referencing these pvds by full
+ * indexes
+ *
+ * If name[0] == '\0' (ie, empty name), then the
+ * pvd is an implicit PvD. In this case, the lla and
+ * dev fields uniquely identify the PvD
+ */
+
+struct net_pvd {
+	struct net_pvd		*next;
+
+	char			name[PVDNAMSIZ];
+	struct hlist_node	name_hlist;
+	int __percpu		*pcpu_refcnt;
+	u32			pvdindex;	/* unique number */
+	int			_index;		/* index in net->pvd_used_slots */
+	int			notifications_blocked;
+
+	/*
+	 * Attributes of the pvd
+	 */
+	int			sequence_number;
+	int			h_flag;
+	int			l_flag;
+	int			implicit_flag;
+
+	/*
+	 * Lot of cross references to other structures belonging to
+	 * this PvD. We have to make sure that we are not referencing
+	 * released pointers (dev, lla, etc.)
+	 */
+	possible_net_t		nd_net;
+
+	struct net_device	*dev;	/* the device it has been received on */
+	struct in6_addr		lla;	/* the associated router lla */
+	int			nroutes;
+	struct rt6_info		*routes[MAXROUTESPERPVD];
+	int			naddresses;
+	struct inet6_ifaddr	*addresses[MAXADDRPERPVD];
+	
+	/*
+	 * The user options below have no existence somewhere
+	 * in the kernel. They are just stored here to
+	 * be provided to the applications
+	 */
+	int			ndnssl;
+	char			*dnssl[MAXDNSSLPERPVD];
+	unsigned long		dnsslExpire[MAXDNSSLPERPVD];
+
+
+	int			nrdnss;
+	struct in6_addr		rdnss[MAXRDNSSPERPVD];
+	unsigned long		rdnssExpire[MAXRDNSSPERPVD];
+
+#ifdef CONFIG_NETPVD
+	/*
+	 * pvd.d/
+	 * 	<pvdname>/
+	 * 		attrs
+	 * 		routes
+	 * 		addrs
+	 * 		sockets
+	 */
+	struct proc_dir_entry 	*proc_pvd;		/* dir */
+	struct proc_dir_entry 	*proc_pvd_attrs;	/* file */
+	struct proc_dir_entry 	*proc_pvd_routes;	/* file */
+	struct proc_dir_entry 	*proc_pvd_addrs;	/* file */
+	struct proc_dir_entry 	*proc_pvd_rdnss;	/* file */
+	struct proc_dir_entry 	*proc_pvd_dnssl;	/* file */
+	struct proc_dir_entry 	*proc_pvd_sockets;	/* file */
+#endif
+};
+
+/*
+ * Bound PvDs. Binding to a set of PvDs can be done at 3 different hierarchical levels
+ * 1) the socket
+ * 2) the thread
+ * 3) the process
+ *
+ * We define here a structure that can be shared between these 3 levels
+ */
+struct kernel_bind_to_pvd {
+	int			refcnt;
+	struct bind_to_pvd	btp;
+};
+
+
+/**
+ *	pvd_put - release reference to pvd
+ *	@pvd: pvd
+ *
+ * Release reference to pvd to allow it to be freed.
+ */
+static inline void pvd_put(struct net_pvd *pvd)
+{
+	if (pvd != NULL) {
+		this_cpu_dec(*pvd->pcpu_refcnt);
+	}
+}
+
+/**
+ *	pvd_hold - get reference to pvd
+ *	@pvd: pvd
+ *
+ * Hold reference to pvd to keep it from being freed.
+ */
+static inline struct net_pvd *pvd_hold(struct net_pvd *pvd)
+{
+	if (pvd != NULL) {
+		this_cpu_inc(*pvd->pcpu_refcnt);
+	}
+	return pvd;
+}
+
+/*
+ * Net namespace inlines
+ */
+static inline
+struct net *pvd_net(const struct net_pvd *pvd)
+{
+	return read_pnet(&pvd->nd_net);
+}
+
+static inline
+void pvd_net_set(struct net_pvd *pvd, struct net *net)
+{
+	write_pnet(&pvd->nd_net, net);
+}
+
+extern void	pvd_rtnl_notify(struct net_pvd *pvd, int state);
+extern void	pvd_register_dnssl(struct net_pvd *pvd, void *dnssl_opt);
+extern void	pvd_register_rdnss(struct net_pvd *pvd, void *rdnss_opt);
+extern int pvd_migrate_route(
+		struct net_pvd *newpvd,
+		struct rt6_info *rt,
+		const char *func);
+extern int pvd_migrate_addr(
+		struct net_pvd *newpvd,
+		struct inet6_ifaddr *addr);
+extern struct net_pvd *register_pvd(
+				struct net *net,
+				char *pvdname,
+				struct net_device *dev,
+				struct in6_addr *lla);
+extern void unregister_pvd(struct net_pvd *pvd);
+extern struct net_pvd *pvd_get_by_name_rcu(
+				struct net *net,
+				const char *pvdname,
+				struct net_device *dev,
+				struct in6_addr *lla);
+extern struct net_pvd *pvd_get_by_name(
+				struct net *net,
+				const char *pvdname,
+				struct net_device *dev,
+				struct in6_addr *lla);
+extern int netpvd_get_name(struct net *net, char *pvdname, u32 pvdindex);
+extern struct net_pvd *__pvd_get_by_fullindex(struct net *net, int fullindex);
+extern int pvd_get_fullindex(struct net_pvd *pvd);
+extern int sock_getbindtopvd(struct sock *sk, char __user *optval,
+				int __user *optlen, int len);
+extern int sock_setbindtopvd(struct sock *sk, char __user *optval,
+				int optlen);
+extern int sock_getpvdattr(
+		struct sock *sk,
+		char __user *optval,
+		int __user *optlen,
+		int len);
+
+extern int sock_createpvd(
+		struct sock *sk,
+		char __user *optval,
+		int optlen);
+
+extern int sock_getpvdlist(
+		struct sock *sk,
+		char __user *optval,
+		int __user *optlen,
+		int len);
+
+extern int sock_getralist(
+		struct sock *sk,
+		char __user *optval,
+		int __user *optlen,
+		int len);
+
+#endif		/* CONFIG_NETPVD */
+
+#endif		/* _NET_PVD_H */
diff -Naur -X DiffNaurExclude ubuntu-4.10.0-orig/include/net/sock.h ubuntu-4.10.0/include/net/sock.h
--- ubuntu-4.10.0-orig/include/net/sock.h	2017-08-10 11:05:24.289046482 +0100
+++ ubuntu-4.10.0/include/net/sock.h	2017-07-18 14:25:07.403522851 +0100
@@ -129,6 +129,7 @@
  *	@skc_reuse: %SO_REUSEADDR setting
  *	@skc_reuseport: %SO_REUSEPORT setting
  *	@skc_bound_dev_if: bound device index if != 0
+ *	@skc_bound_pvd_ix: bound pvd index if != 0
  *	@skc_bind_node: bind hash linkage for various protocol lookup tables
  *	@skc_portaddr_node: second hash linkage for UDP/UDP-Lite protocol
  *	@skc_prot: protocol handlers inside a network family
@@ -176,6 +177,10 @@
 	unsigned char		skc_ipv6only:1;
 	unsigned char		skc_net_refcnt:1;
 	int			skc_bound_dev_if;
+#ifdef	CONFIG_NETPVD
+	int			skc_n_bound_pvd;	/* -1 : undefined, #-1 : forcibly set */
+	int			skc_bound_pvds[32];	/* FIXME : use MAXBOUNDPVD instead */
+#endif
 	union {
 		struct hlist_node	skc_bind_node;
 		struct hlist_node	skc_portaddr_node;
@@ -332,6 +337,8 @@
 #define sk_ipv6only		__sk_common.skc_ipv6only
 #define sk_net_refcnt		__sk_common.skc_net_refcnt
 #define sk_bound_dev_if		__sk_common.skc_bound_dev_if
+#define sk_n_bound_pvd		__sk_common.skc_n_bound_pvd
+#define sk_bound_pvds		__sk_common.skc_bound_pvds
 #define sk_bind_node		__sk_common.skc_bind_node
 #define sk_prot			__sk_common.skc_prot
 #define sk_net			__sk_common.skc_net
diff -Naur -X DiffNaurExclude ubuntu-4.10.0-orig/include/uapi/asm-generic/socket.h ubuntu-4.10.0/include/uapi/asm-generic/socket.h
--- ubuntu-4.10.0-orig/include/uapi/asm-generic/socket.h	2017-08-10 11:05:24.289046482 +0100
+++ ubuntu-4.10.0/include/uapi/asm-generic/socket.h	2017-07-31 14:34:24.924687782 +0100
@@ -94,4 +94,10 @@
 
 #define SCM_TIMESTAMPING_OPT_STATS	54
 
+/* PVD specific options (FIXME : probably not the best place) */
+#define	SO_BINDTOPVD		55
+#define	SO_GETPVDLIST		56
+#define	SO_GETPVDATTRIBUTES	57
+#define	SO_CREATEPVD		58
+
 #endif /* __ASM_GENERIC_SOCKET_H */
diff -Naur -X DiffNaurExclude ubuntu-4.10.0-orig/include/uapi/linux/if_addr.h ubuntu-4.10.0/include/uapi/linux/if_addr.h
--- ubuntu-4.10.0-orig/include/uapi/linux/if_addr.h	2017-08-10 11:05:24.289046482 +0100
+++ ubuntu-4.10.0/include/uapi/linux/if_addr.h	2017-07-18 14:25:07.403522851 +0100
@@ -32,6 +32,7 @@
 	IFA_CACHEINFO,
 	IFA_MULTICAST,
 	IFA_FLAGS,
+	IFA_PVD,
 	__IFA_MAX,
 };
 
diff -Naur -X DiffNaurExclude ubuntu-4.10.0-orig/include/uapi/linux/Kbuild ubuntu-4.10.0/include/uapi/linux/Kbuild
--- ubuntu-4.10.0-orig/include/uapi/linux/Kbuild	2017-08-10 11:05:24.289046482 +0100
+++ ubuntu-4.10.0/include/uapi/linux/Kbuild	2017-07-18 14:25:07.403522851 +0100
@@ -353,6 +353,7 @@
 header-y += psci.h
 header-y += ptp_clock.h
 header-y += ptrace.h
+header-y += pvd-user.h
 header-y += qnx4_fs.h
 header-y += qnxtypes.h
 header-y += quota.h
diff -Naur -X DiffNaurExclude ubuntu-4.10.0-orig/include/uapi/linux/pvd-user.h ubuntu-4.10.0/include/uapi/linux/pvd-user.h
--- ubuntu-4.10.0-orig/include/uapi/linux/pvd-user.h	1970-01-01 01:00:00.000000000 +0100
+++ ubuntu-4.10.0/include/uapi/linux/pvd-user.h	2017-07-28 16:41:26.015471853 +0100
@@ -0,0 +1,194 @@
+/*
+ * This header file contains definitions for use when exchanging
+ * data with the user space
+ *
+ * The same file will also be installed for use by user space
+ * applications
+ *
+ * SO_GETPVDINFO, SO_BINDTOPVD and SO_GETRALIST are defined in
+ * another uapi header file (asm-generic/socket.h)
+ */
+#ifndef	_UAPI_LINUX_PVD_USER_H
+#define	_UAPI_LINUX_PVD_USER_H
+
+#include <linux/in6.h>
+#ifndef __KERNEL__
+#include <net/if.h>
+#else
+#include <linux/if.h>
+#endif
+#include <linux/ipv6_route.h>
+
+/*
+ * MAXPVD must be a power of 2
+ */
+#define	MAXPVDSHIFT	10	/* realistic upper bound */
+#define	MAXPVD		(1 << MAXPVDSHIFT)
+
+#ifndef	PVDNAMSIZ
+#define	PVDNAMSIZ	256
+#endif
+
+#ifndef	FQDNSIZ
+#define	FQDNSIZ		256
+#endif
+
+#ifndef MAXADDRPERPVD
+#define	MAXADDRPERPVD	32
+#endif
+
+#ifndef MAXROUTESPERPVD
+#define	MAXROUTESPERPVD	32
+#endif
+
+#ifndef	MAXDNSSLPERPVD
+#define	MAXDNSSLPERPVD	4
+#endif
+
+#ifndef	MAXRDNSSPERPVD
+#define	MAXRDNSSPERPVD	4
+#endif
+
+/*
+ * For SO_GETPVDINFO (which returns in one call all pvd and
+ * their attributes) or SO_GETPVDATTRIBUTES (which returns
+ * the attributes for a given PvD)
+ *
+ * The net_pvd_attribute structure below is a copy of the
+ * kernel space pvd structure, with kernel specific items
+ * removed
+ */
+struct net_pvd_route {
+	struct in6_addr	dst;
+	struct in6_addr gateway;
+	char dev_name[IFNAMSIZ];
+};
+
+struct net_pvd_attribute {
+	char			name[PVDNAMSIZ];
+	int			index;	/* unique number */
+
+	/*
+	 * Attributes of the pvd
+	 */
+	int			sequence_number;
+	int			h_flag;
+	int			l_flag;
+	int			implicit_flag;
+	struct in6_addr		lla;
+	char			dev[IFNAMSIZ];
+
+	/*
+	 * Induced attributes
+	 */
+	int			nroutes;
+	struct net_pvd_route	routes[MAXROUTESPERPVD];
+	int			naddresses;
+	struct in6_addr		addresses[MAXADDRPERPVD];
+	int			addr_prefix_len[MAXADDRPERPVD];
+
+	int			ndnssl;
+	char			dnssl[MAXDNSSLPERPVD][FQDNSIZ];
+
+	int			nrdnss;
+	struct in6_addr		rdnss[MAXRDNSSPERPVD];
+};
+
+struct pvd_list {
+	int npvd;	/* in/out */
+	char pvds[MAXPVD][PVDNAMSIZ];
+};
+
+struct pvd_attr {
+	char __user *pvdname;	/* in */
+	struct net_pvd_attribute *pvdattr;	/* out */
+};
+
+/*
+ * For SO_BINDTOPVD (set and get)
+ */
+#define	MAXBOUNDPVD	32	/* 1 practically after discussions */
+
+#define	PVD_BIND_SCOPE_SOCKET	0
+#define	PVD_BIND_SCOPE_THREAD	1
+#define	PVD_BIND_SCOPE_PROCESS	2
+
+struct bind_to_pvd {
+	int scope;
+	int npvd;	/* in/out */
+	char pvdnames[MAXBOUNDPVD][PVDNAMSIZ];
+};
+
+/*
+ * For SO_CREATEPVD
+ */
+struct create_pvd {
+	char pvdname[PVDNAMSIZ];
+	int flag;	/* mask : see below PVD_ATTR_XXX */
+	int sequence_number;
+	int h_flag;
+	int l_flag;
+	int deprecated;
+};
+
+#define	PVD_ATTR_SEQNUMBER	0x01
+#define	PVD_ATTR_HFLAG		0x02
+#define	PVD_ATTR_LFLAG		0x04
+#define	PVD_ATTR_DEPRECATED	0x08
+
+/*
+ * For SO_RT6PVD
+ */
+struct in6_rt_pvdmsg {
+	char pvdname[PVDNAMSIZ];
+	struct in6_rtmsg rtmsg;
+};
+
+/*
+ * RTNETLINK related definitions
+ */
+/********************************************************************
+ *		PvD description
+ *		This is used to notify a change in a PvD
+ *		Application may then query the attributes for the
+ *		notified PvD using an alternate API
+ ****/
+
+struct pvdmsg {
+	char	pvd_name[PVDNAMSIZ];
+	int	pvd_state;	/* NEW, UPDATE, DEL */
+};
+
+enum {
+	/*
+	 * PVD_NEW and PVD_UPDATE will certainly be handled in the same way
+	 * by application
+	 */
+	PVD_NEW,
+	PVD_UPDATE,
+	PVD_DEL
+};
+
+struct rdnssmsg {
+	char	pvd_name[PVDNAMSIZ];
+	struct in6_addr	rdnss;
+	int		rdnss_state;	/* NEW, DEL */
+};
+
+enum {
+	RDNSS_NEW,
+	RDNSS_DEL
+};
+
+struct dnsslmsg {
+	char	pvd_name[PVDNAMSIZ];
+	char	dnssl[FQDNSIZ];
+	int	dnssl_state;	/* NEW, DEL */
+};
+
+enum {
+	DNSSL_NEW,
+	DNSSL_DEL
+};
+
+#endif		/* _UAPI_LINUX_PVD_USER_H */
diff -Naur -X DiffNaurExclude ubuntu-4.10.0-orig/include/uapi/linux/rtnetlink.h ubuntu-4.10.0/include/uapi/linux/rtnetlink.h
--- ubuntu-4.10.0-orig/include/uapi/linux/rtnetlink.h	2017-08-10 11:05:24.289046482 +0100
+++ ubuntu-4.10.0/include/uapi/linux/rtnetlink.h	2017-07-18 14:25:07.407522851 +0100
@@ -122,6 +122,8 @@
 
 	RTM_NEWNETCONF = 80,
 #define RTM_NEWNETCONF RTM_NEWNETCONF
+	RTM_DELNETCONF,
+#define RTM_DELNETCONF RTM_DELNETCONF
 	RTM_GETNETCONF = 82,
 #define RTM_GETNETCONF RTM_GETNETCONF
 
@@ -144,6 +146,13 @@
 	RTM_GETSTATS = 94,
 #define RTM_GETSTATS RTM_GETSTATS
 
+	RTM_PVDSTATUS = 96,
+#define RTM_PVDSTATUS RTM_PVDSTATUS
+	RTM_RDNSS = 97,
+#define RTM_RDNSS RTM_RDNSS
+	RTM_DNSSL = 98,
+#define RTM_DNSSL RTM_DNSSL
+
 	__RTM_MAX,
 #define RTM_MAX		(((__RTM_MAX + 3) & ~3) - 1)
 };
@@ -319,6 +328,8 @@
 	RTA_EXPIRES,
 	RTA_PAD,
 	RTA_UID,
+	RTA_TTL_PROPAGATE,
+	RTA_PVD,
 	__RTA_MAX
 };
 
@@ -350,6 +361,7 @@
 #define RTNH_F_ONLINK		4	/* Gateway is forced on link	*/
 #define RTNH_F_OFFLOAD		8	/* offloaded route */
 #define RTNH_F_LINKDOWN		16	/* carrier-down on nexthop */
+#define RTNH_F_UNRESOLVED	32	/* The entry is unresolved (ipmr) */
 
 #define RTNH_COMPARE_MASK	(RTNH_F_DEAD | RTNH_F_LINKDOWN | RTNH_F_OFFLOAD)
 
@@ -544,6 +556,7 @@
 	TCA_STATS2,
 	TCA_STAB,
 	TCA_PAD,
+	TCA_DUMP_INVISIBLE,
 	__TCA_MAX
 };
 
@@ -576,7 +589,6 @@
 
 #define NDUSEROPT_MAX	(__NDUSEROPT_MAX - 1)
 
-#ifndef __KERNEL__
 /* RTnetlink multicast groups - backwards compatibility for userspace */
 #define RTMGRP_LINK		1
 #define RTMGRP_NOTIFY		2
@@ -597,7 +609,6 @@
 #define RTMGRP_DECnet_ROUTE     0x4000
 
 #define RTMGRP_IPV6_PREFIX	0x20000
-#endif
 
 /* RTnetlink multicast groups */
 enum rtnetlink_groups {
@@ -657,6 +668,12 @@
 #define RTNLGRP_MPLS_ROUTE	RTNLGRP_MPLS_ROUTE
 	RTNLGRP_NSID,
 #define RTNLGRP_NSID		RTNLGRP_NSID
+	RTNLGRP_MPLS_NETCONF,
+#define RTNLGRP_MPLS_NETCONF	RTNLGRP_MPLS_NETCONF
+
+	RTNLGRP_PVD,
+#define RTNLGRP_PVD		RTNLGRP_PVD
+
 	__RTNLGRP_MAX
 };
 #define RTNLGRP_MAX	(__RTNLGRP_MAX - 1)
diff -Naur -X DiffNaurExclude ubuntu-4.10.0-orig/kernel/configs/kvm_guest.config ubuntu-4.10.0/kernel/configs/kvm_guest.config
--- ubuntu-4.10.0-orig/kernel/configs/kvm_guest.config	2017-08-10 11:05:24.289046482 +0100
+++ ubuntu-4.10.0/kernel/configs/kvm_guest.config	2017-07-18 14:25:07.407522851 +0100
@@ -1,6 +1,7 @@
 CONFIG_NET=y
 CONFIG_NET_CORE=y
 CONFIG_NETDEVICES=y
+CONFIG_NETPVD=y
 CONFIG_BLOCK=y
 CONFIG_BLK_DEV=y
 CONFIG_NETWORK_FILESYSTEMS=y
diff -Naur -X DiffNaurExclude ubuntu-4.10.0-orig/net/6lowpan/core.c ubuntu-4.10.0/net/6lowpan/core.c
--- ubuntu-4.10.0-orig/net/6lowpan/core.c	2017-08-10 11:05:24.289046482 +0100
+++ ubuntu-4.10.0/net/6lowpan/core.c	2017-07-18 14:25:07.407522851 +0100
@@ -127,7 +127,7 @@
 		    addrconf_ifid_802154_6lowpan(addr.s6_addr + 8, dev) == 0) {
 			__ipv6_addr_set_half(&addr.s6_addr32[0],
 					     htonl(0xFE800000), 0);
-			addrconf_add_linklocal(idev, &addr, 0);
+			addrconf_add_linklocal(idev, &addr, 0, NULL);	/* FIXME : pvd == NULL ? */
 		}
 		break;
 	case NETDEV_DOWN:
diff -Naur -X DiffNaurExclude ubuntu-4.10.0-orig/net/6lowpan/ndisc.c ubuntu-4.10.0/net/6lowpan/ndisc.c
--- ubuntu-4.10.0-orig/net/6lowpan/ndisc.c	2017-08-10 11:05:24.289046482 +0100
+++ ubuntu-4.10.0/net/6lowpan/ndisc.c	2017-07-18 14:25:07.407522851 +0100
@@ -208,7 +208,8 @@
 					     bool sllao, bool tokenized,
 					     __u32 valid_lft,
 					     u32 prefered_lft,
-					     bool dev_addr_generated)
+					     bool dev_addr_generated,
+					     void *pvd)
 {
 	int err;
 
@@ -218,7 +219,8 @@
 		err = addrconf_prefix_rcv_add_addr(net, dev, pinfo, in6_dev,
 						   addr, addr_type, addr_flags,
 						   sllao, tokenized, valid_lft,
-						   prefered_lft);
+						   prefered_lft,
+						   pvd);
 		if (err)
 			ND_PRINTK(2, warn,
 				  "RA: could not add a short address based address for prefix: %pI6c\n",
diff -Naur -X DiffNaurExclude ubuntu-4.10.0-orig/net/core/Makefile ubuntu-4.10.0/net/core/Makefile
--- ubuntu-4.10.0-orig/net/core/Makefile	2017-08-10 11:05:24.289046482 +0100
+++ ubuntu-4.10.0/net/core/Makefile	2017-07-18 14:25:07.407522851 +0100
@@ -28,3 +28,4 @@
 obj-$(CONFIG_DST_CACHE) += dst_cache.o
 obj-$(CONFIG_HWBM) += hwbm.o
 obj-$(CONFIG_NET_DEVLINK) += devlink.o
+obj-$(CONFIG_NETPVD) += pvd.o
diff -Naur -X DiffNaurExclude ubuntu-4.10.0-orig/net/core/pvd.c ubuntu-4.10.0/net/core/pvd.c
--- ubuntu-4.10.0-orig/net/core/pvd.c	1970-01-01 01:00:00.000000000 +0100
+++ ubuntu-4.10.0/net/core/pvd.c	2017-07-31 09:11:39.084594183 +0100
@@ -0,0 +1,2227 @@
+/*
+ */
+
+/*
+ * TODO : have a growable array of pvds in the struct net structure
+ */
+#include <net/net_namespace.h>
+#include <linux/netdevice.h>
+#include <linux/rtnetlink.h>
+#include <linux/percpu.h>
+#include <linux/hash.h>
+#include <linux/list.h>
+#include <linux/timer.h>
+#include <linux/rculist.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <net/sock.h>
+
+#include <linux/net.h>
+#include <linux/route.h>
+#include <linux/netdevice.h>
+#include <linux/in6.h>
+#include <net/ipv6.h>
+#include <net/ip6_fib.h>
+#include <net/ip6_route.h>
+
+#include <linux/if_addr.h>
+#include <linux/if_arp.h>
+#include <linux/ipv6.h>
+#include <linux/icmpv6.h>
+#include <net/ipv6.h>
+#include <net/ip6_fib.h>
+#include <net/ip6_route.h>
+
+#include <net/pvd.h>
+#include <linux/pvd-user.h>
+
+#ifdef	CONFIG_NETPVD
+
+#define	DIM(t)	(sizeof(t) / sizeof(t[0]))
+
+#define	MAXPVDINDEX	(1 << (32 - MAXPVDSHIFT))
+#define	_TABIDX(f)	((f) & ((1 << MAXPVDSHIFT) - 1))
+#define	_UNIQIDX(f)	(((f) >> MAXPVDSHIFT) & (MAXPVDINDEX - 1))
+
+struct nd_opt_rdnss_info {
+	uint8_t nd_opt_rdnssi_type;
+	uint8_t nd_opt_rdnssi_len;
+	uint16_t nd_opt_rdnssi_pref_flag_reserved;
+	uint32_t nd_opt_rdnssi_lifetime;
+	struct in6_addr nd_opt_rdnssi_addr1;
+	struct in6_addr nd_opt_rdnssi_addr2;
+	struct in6_addr nd_opt_rdnssi_addr3;
+};
+
+struct nd_opt_dnssl_info {
+	uint8_t nd_opt_dnssli_type;
+	uint8_t nd_opt_dnssli_len;
+	uint16_t nd_opt_dnssli_reserved;
+	uint32_t nd_opt_dnssli_lifetime;
+	unsigned char nd_opt_dnssli_suffixes[];
+};
+
+static seqcount_t pvd_rename_seq;
+
+static void pvd_check_lifetimes(unsigned long arg);
+static struct net_pvd	*__register_pvd(
+				struct net *net,
+				char *pvdname,
+				struct net_device *dev,
+				struct in6_addr *lla);
+static void __unregister_pvd(struct net_pvd *pvd);
+
+static char *addrtostr(struct in6_addr const *addr, char *str)
+{
+	sprintf(str,
+		"%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x",
+		addr->s6_addr[0], addr->s6_addr[1],
+		addr->s6_addr[2], addr->s6_addr[3],
+		addr->s6_addr[4], addr->s6_addr[5],
+		addr->s6_addr[6], addr->s6_addr[7],
+		addr->s6_addr[8], addr->s6_addr[9],
+		addr->s6_addr[10], addr->s6_addr[11],
+		addr->s6_addr[12], addr->s6_addr[13],
+		addr->s6_addr[14], addr->s6_addr[15]);
+
+	return str;
+}
+
+/* Initialize per network namespace state */
+static int __net_init netpvd_init(struct net *net)
+{
+	int i;
+
+	setup_timer(&net->pvd_timer, pvd_check_lifetimes, (unsigned long) net);
+
+	net->pvdindex = 0;
+
+	for (i = 0; i < MAXPVD; i++) {
+		net->pvd_free_slots[i] = i == MAXPVD - 1 ? -1 : i + 1;
+		net->pvd_used_slots[i] = NULL;
+	}
+	net->first_free_pvd_ix = 0;
+	net->first_used_pvd = NULL;
+
+	return 0;
+}
+
+static void __net_exit netpvd_exit(struct net *net)
+{
+	del_timer_sync(&net->pvd_timer);
+}
+
+static struct pernet_operations __net_initdata netpvd_net_ops = {
+	.init = netpvd_init,
+	.exit = netpvd_exit,
+};
+
+/*
+ * The @first_used_pvd list is protected by @pvd_base_lock and the rtnl
+ * semaphore.
+ *
+ * Pure readers hold pvd_base_lock for reading, or rcu_read_lock()
+ *
+ * Writers must hold the rtnl semaphore while they loop through the
+ * first_used_pvd list, and hold pvd_base_lock for writing when they do the
+ * actual updates.  This allows pure readers to access the list even
+ * while a writer is preparing to update it.
+ *
+ * To put it another way, pvd_base_lock is held for writing only to
+ * protect against pure readers; the rtnl semaphore provides the
+ * protection against other writers.
+ *
+ * See, for example usages, register_netdevice() and
+ * unregister_netdevice(), which must be called with the rtnl
+ * semaphore held.
+ */
+DEFINE_RWLOCK(pvd_base_lock);
+EXPORT_SYMBOL(pvd_base_lock);
+
+#ifdef CONFIG_PROC_FS
+
+static int pvd_attrs_seq_show(struct seq_file *seq, void *v)
+{
+	struct net_pvd *pvd = (struct net_pvd *) seq->private;
+	char sAddr[64];
+
+	rcu_read_lock();
+
+	seq_printf(
+		seq,
+		"seq=%d h=%s l=%s index=%lu lla=%s dev=%s\n",
+		pvd->sequence_number,
+		pvd->h_flag ? "true" : "false",
+		pvd->l_flag ? "true" : "false",
+		(unsigned long) pvd_get_fullindex(pvd),
+		addrtostr(&pvd->lla, sAddr),
+		pvd->dev ? pvd->dev->name : "<nodev>");
+
+	rcu_read_unlock();
+
+	return 0;
+}
+
+static int pvd_attrs_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, pvd_attrs_seq_show, PDE_DATA(inode));
+}
+
+static const struct file_operations pvd_attrs_seq_fops = {
+	.owner	 = THIS_MODULE,
+	.open	 = pvd_attrs_seq_open,
+	.read	 = seq_read,
+	.llseek	 = seq_lseek,
+	.release = single_release,
+};
+
+static int pvd_routes_seq_show(struct seq_file *seq, void *v)
+{
+	int i;
+	struct net_pvd *pvd = (struct net_pvd *) seq->private;
+
+	rcu_read_lock();
+
+	for (i = 0; i < pvd->nroutes; i++) {
+		struct rt6_info *rt = pvd->routes[i];
+		char sAddr[64];
+		unsigned long lt;
+
+		seq_printf(seq, "%3d : ", i);
+		seq_printf(seq, "%s/%-3d ", 
+			   addrtostr(&rt->rt6i_dst.addr, sAddr),
+			   rt->rt6i_dst.plen);
+
+#ifdef CONFIG_IPV6_SUBTREES
+		seq_printf(seq, "%s/%-3d ",
+			   addrtostr(&rt->rt6i_src.addr, sAddr),
+			   rt->rt6i_src.plen);
+#else
+		seq_printf(seq, "0000:0000:0000:0000:0000:0000:0000:0000/00 ");
+#endif
+		if (rt->rt6i_flags & RTF_GATEWAY)
+			seq_printf(seq, "%s", addrtostr(&rt->rt6i_gateway, sAddr));
+		else
+			seq_puts(seq, "0000:0000:0000:0000:0000:0000:0000:0000");
+
+		lt = (rt->dst.expires - jiffies) / HZ;
+
+		seq_printf(seq, " %5u %3u %08x %8s (%ld)\n",
+			   rt->rt6i_metric,
+			   atomic_read(&rt->dst.__refcnt),
+			   rt->rt6i_flags,
+			   rt->dst.dev ? rt->dst.dev->name : "",
+			   rt->dst.expires == 0 || lt > 0xffff0000UL ? -1 : lt);
+	}
+
+	rcu_read_unlock();
+
+	return 0;
+}
+
+static int pvd_routes_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, pvd_routes_seq_show, PDE_DATA(inode));
+}
+
+static const struct file_operations pvd_routes_seq_fops = {
+	.owner	 = THIS_MODULE,
+	.open	 = pvd_routes_seq_open,
+	.read	 = seq_read,
+	.llseek	 = seq_lseek,
+	.release = single_release,
+};
+
+static int pvd_addrs_seq_show(struct seq_file *seq, void *v)
+{
+	int i;
+	struct net_pvd *pvd = (struct net_pvd *) seq->private;
+
+	rcu_read_lock();
+
+	for (i = 0; i < pvd->naddresses; i++) {
+		struct inet6_ifaddr *ifa = pvd->addresses[i];
+		char sAddr[64];
+
+		seq_printf(seq, "%3d : %s/%d %s (%p)\n", 
+			   i,
+			   addrtostr(&ifa->addr, sAddr),
+			   ifa->prefix_len,
+			   ifa->idev->dev->name,
+			   ifa);
+	}
+
+	rcu_read_unlock();
+
+	return 0;
+}
+
+static int pvd_addrs_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, pvd_addrs_seq_show, PDE_DATA(inode));
+}
+
+static const struct file_operations pvd_addrs_seq_fops = {
+	.owner	 = THIS_MODULE,
+	.open	 = pvd_addrs_seq_open,
+	.read	 = seq_read,
+	.llseek	 = seq_lseek,
+	.release = single_release,
+};
+
+static int pvd_rdnss_seq_show(struct seq_file *seq, void *v)
+{
+	int i;
+	struct net_pvd *pvd = (struct net_pvd *) seq->private;
+
+	rcu_read_lock();
+
+	for (i = 0; i < pvd->nrdnss; i++) {
+		char sAddr[64];
+
+		seq_printf(seq, "%3d : %s\n", 
+			   i,
+			   addrtostr(&pvd->rdnss[i], sAddr));
+	}
+
+	rcu_read_unlock();
+
+	return 0;
+}
+
+static int pvd_rdnss_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, pvd_rdnss_seq_show, PDE_DATA(inode));
+}
+
+static const struct file_operations pvd_rdnss_seq_fops = {
+	.owner	 = THIS_MODULE,
+	.open	 = pvd_rdnss_seq_open,
+	.read	 = seq_read,
+	.llseek	 = seq_lseek,
+	.release = single_release,
+};
+
+static int pvd_dnssl_seq_show(struct seq_file *seq, void *v)
+{
+	int i;
+	struct net_pvd *pvd = (struct net_pvd *) seq->private;
+
+	rcu_read_lock();
+
+	for (i = 0; i < pvd->ndnssl; i++) {
+		seq_printf(seq, "%3d :  %s\n", i, pvd->dnssl[i]);
+	}
+
+	rcu_read_unlock();
+
+	return 0;
+}
+
+static int pvd_dnssl_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, pvd_dnssl_seq_show, PDE_DATA(inode));
+}
+
+static const struct file_operations pvd_dnssl_seq_fops = {
+	.owner	 = THIS_MODULE,
+	.open	 = pvd_dnssl_seq_open,
+	.read	 = seq_read,
+	.llseek	 = seq_lseek,
+	.release = single_release,
+};
+
+static int pvd_sockets_seq_show(struct seq_file *seq, void *v)
+{
+	seq_printf(seq, "sockets : not implemented\n");
+
+	return 0;
+}
+
+static int pvd_sockets_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, pvd_sockets_seq_show, PDE_DATA(inode));
+}
+
+static const struct file_operations pvd_sockets_seq_fops = {
+	.owner	 = THIS_MODULE,
+	.open	 = pvd_sockets_seq_open,
+	.read	 = seq_read,
+	.llseek	 = seq_lseek,
+	.release = single_release,
+};
+
+static int register_proc_pvd(struct net *net, struct net_pvd *pvd)
+{
+	if (net->proc_pvdd == NULL) {
+		return -ENOENT;	/* should not happen */
+	}
+
+	if ((pvd->proc_pvd = proc_mkdir(pvd->name, net->proc_pvdd)) == NULL) {
+		return -ENOENT;
+	}
+
+	if ((pvd->proc_pvd_attrs = proc_create_data(
+					"attrs", S_IRUGO,
+					pvd->proc_pvd,
+					&pvd_attrs_seq_fops,
+					pvd)) == NULL) {
+		return -ENOENT;
+	}
+
+	if ((pvd->proc_pvd_routes = proc_create_data(
+					"routes", S_IRUGO,
+					pvd->proc_pvd,
+					&pvd_routes_seq_fops,
+					pvd)) == NULL) {
+		return -ENOENT;
+	}
+
+	if ((pvd->proc_pvd_addrs = proc_create_data(
+					"addrs", S_IRUGO,
+					pvd->proc_pvd,
+					&pvd_addrs_seq_fops,
+					pvd)) == NULL) {
+		return -ENOENT;
+	}
+
+	if ((pvd->proc_pvd_rdnss = proc_create_data(
+					"rdnss", S_IRUGO,
+					pvd->proc_pvd,
+					&pvd_rdnss_seq_fops,
+					pvd)) == NULL) {
+		return -ENOENT;
+	}
+
+	if ((pvd->proc_pvd_dnssl = proc_create_data(
+					"dnssl", S_IRUGO,
+					pvd->proc_pvd,
+					&pvd_dnssl_seq_fops,
+					pvd)) == NULL) {
+		return -ENOENT;
+	}
+
+	if ((pvd->proc_pvd_sockets = proc_create_data(
+					"sockets", S_IRUGO,
+					pvd->proc_pvd,
+					&pvd_sockets_seq_fops,
+					pvd)) == NULL) {
+		return -ENOENT;
+	}
+
+	return 0;
+}
+
+static int unregister_proc_pvd(struct net *net, struct net_pvd *pvd)
+{
+	if (net->proc_pvdd == NULL) {
+		return -ENOENT;
+	}
+	if (pvd->proc_pvd == NULL) {
+		return -EINVAL;
+	}
+	proc_remove(pvd->proc_pvd);
+	pvd->proc_pvd = NULL;
+	pvd->proc_pvd_attrs = NULL;
+	pvd->proc_pvd_routes = NULL;
+	pvd->proc_pvd_addrs = NULL;
+	pvd->proc_pvd_rdnss = NULL;
+	pvd->proc_pvd_dnssl = NULL;
+	pvd->proc_pvd_sockets = NULL;
+
+	return 0;
+}
+
+static int netpvd_seq_show(struct seq_file *seq, void *v)
+{
+	struct net *net = (struct net *) seq->private;
+	struct net_pvd *pvd;
+	char sAddr[64];
+
+	rtnl_lock();
+	rcu_read_lock();
+
+	for (pvd = net->first_used_pvd; pvd; pvd = pvd->next) {
+		seq_printf(
+			seq,
+			"name=%s seq=%d h=%s l=%s index=%lu lla=%s dev=%s\n",
+			pvd->name,
+			pvd->sequence_number,
+			pvd->h_flag ? "true" : "false",
+			pvd->l_flag ? "true" : "false",
+			(unsigned long) pvd_get_fullindex(pvd),
+			addrtostr(&pvd->lla, sAddr),
+			pvd->dev ? pvd->dev->name : "<nodev>");
+	}
+
+	rcu_read_unlock();
+	rtnl_unlock();
+
+	return 0;
+}
+
+static int netpvd_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open_net(inode, file, netpvd_seq_show);
+}
+
+static const struct file_operations netpvd_proc_fops = {
+	.owner	 = THIS_MODULE,
+	.open	 = netpvd_seq_open,
+	.read	 = seq_read,
+	.llseek	 = seq_lseek,
+	.release = single_release_net,
+};
+
+static int __net_init netpvd_proc_init(struct net *net)
+{
+	if (! proc_create("pvd", 0, net->proc_net, &netpvd_proc_fops)) {
+		return -ENOMEM;
+	}
+
+	if ((net->proc_pvdd = proc_mkdir("pvd.d", net->proc_net)) == NULL) {
+		remove_proc_entry("pvds", net->proc_net);
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+static void __net_exit netpvd_proc_exit(struct net *net)
+{
+	remove_proc_entry("pvd", net->proc_net);
+	remove_proc_entry("pvd.d", net->proc_net);
+}
+
+static struct pernet_operations netpvd_proc_ops = {
+	.init = netpvd_proc_init,
+	.exit = netpvd_proc_exit,
+};
+#endif
+
+/*
+ * Netlink related functions
+ */
+void	pvd_rtnl_notify(struct net_pvd *pvd, int state)
+{
+	struct net *net = pvd_net(pvd);
+	struct sk_buff *skb;
+	struct nlmsghdr *nlh;
+	struct pvdmsg *pvdmsg;
+	int err;
+	int msg_size = NLMSG_ALIGN(sizeof(struct pvdmsg));
+
+	if (pvd->notifications_blocked) {
+		return;
+	}
+
+	skb = nlmsg_new(msg_size, GFP_ATOMIC);
+	if (!skb) {
+		err = -ENOBUFS;
+		goto errout;
+	}
+
+	nlh = nlmsg_put(skb, 0, 0, RTM_PVDSTATUS, msg_size, 0);
+	if (!nlh) {
+		goto nla_put_failure;
+	}
+
+	pvdmsg = nlmsg_data(nlh);
+	pvdmsg->pvd_state = state;
+	strcpy(pvdmsg->pvd_name, pvd->name);
+
+	nlmsg_end(skb, nlh);
+
+	rtnl_notify(skb, net, 0, RTNLGRP_PVD, NULL, GFP_ATOMIC);
+	return;
+
+nla_put_failure:
+	nlmsg_free(skb);
+	err = -EMSGSIZE;
+errout:
+	rtnl_set_sk_err(net, RTNLGRP_PVD, err);
+}
+
+void	rdnss_rtnl_notify(
+		struct net_pvd *pvd,
+		struct in6_addr *rdnss,
+		int state)
+{
+	struct net *net = pvd_net(pvd);
+	struct sk_buff *skb;
+	struct nlmsghdr *nlh;
+	struct rdnssmsg *rdnssmsg;
+	int err;
+	int msg_size = NLMSG_ALIGN(sizeof(struct rdnssmsg));
+
+	skb = nlmsg_new(msg_size, GFP_ATOMIC);
+	if (!skb) {
+		err = -ENOBUFS;
+		goto errout;
+	}
+
+	nlh = nlmsg_put(skb, 0, 0, RTM_RDNSS, msg_size, 0);
+	if (!nlh) {
+		goto nla_put_failure;
+	}
+
+	rdnssmsg = nlmsg_data(nlh);
+	rdnssmsg->rdnss_state = state;
+	strcpy(rdnssmsg->pvd_name, pvd->name);
+	memcpy(&rdnssmsg->rdnss, rdnss, sizeof(rdnssmsg->rdnss));
+
+	nlmsg_end(skb, nlh);
+
+	rtnl_notify(skb, net, 0, RTNLGRP_PVD, NULL, GFP_ATOMIC);
+	return;
+
+nla_put_failure:
+	nlmsg_free(skb);
+	err = -EMSGSIZE;
+errout:
+	rtnl_set_sk_err(net, RTNLGRP_PVD, err);
+}
+
+void	dnssl_rtnl_notify(
+		struct net_pvd *pvd,
+		char *dnssl,
+		int state)
+{
+	struct net *net = pvd_net(pvd);
+	struct sk_buff *skb;
+	struct nlmsghdr *nlh;
+	struct dnsslmsg *dnsslmsg;
+	int err;
+	int msg_size = NLMSG_ALIGN(sizeof(struct dnsslmsg));
+
+	skb = nlmsg_new(msg_size, GFP_ATOMIC);
+	if (!skb) {
+		err = -ENOBUFS;
+		goto errout;
+	}
+
+	nlh = nlmsg_put(skb, 0, 0, RTM_DNSSL, msg_size, 0);
+	if (!nlh) {
+		goto nla_put_failure;
+	}
+
+	dnsslmsg = nlmsg_data(nlh);
+	dnsslmsg->dnssl_state = state;
+	strcpy(dnsslmsg->pvd_name, pvd->name);
+	strcpy(dnsslmsg->dnssl, dnssl);
+
+	nlmsg_end(skb, nlh);
+
+	rtnl_notify(skb, net, 0, RTNLGRP_PVD, NULL, GFP_ATOMIC);
+	return;
+
+nla_put_failure:
+	nlmsg_free(skb);
+	err = -EMSGSIZE;
+errout:
+	rtnl_set_sk_err(net, RTNLGRP_PVD, err);
+}
+
+/*
+ * pvd_migrate_route : some routes are created via RA
+ * or manually associated to a pvd. We want to be able to find the pvd
+ * associated to the route and, conversely, find all routes attached
+ * to a pvd
+ * Routes can also migrate from one pvd to another one. This function
+ * updates the different links between pvds and ruotes
+ * A route associated to no pvd has its ->pvd field == NULL
+ *
+ * A reference is hold on the route on success as well as on the
+ * pvd
+ *
+ * FIXME : check if rtnl_lock() must be taken here !
+ */
+/*
+ * pvd_migrate_route : migrate a route from its current pvd to a new pvd
+ * Its current pvd might be NULL
+ *
+ * We want to ignore routes with the DST_NOCOUNT flag
+ */
+int	pvd_migrate_route(
+		struct net_pvd *newpvd,
+		struct rt6_info *rt,
+		const char *func)
+{
+	int		i;
+	int		deltaCount = 0;
+	struct net_pvd	*oldpvd;
+	int		rc = 0;
+
+	if (rt == NULL) {
+		return(0);
+	}
+
+	oldpvd = rt->rt6i_pvd;
+
+	printk("pvd_migrate_route(pvd = %s, oldpvd = %s, rt = %p, dev = %s) called by %s\n",
+		newpvd ? newpvd->name : "<no pvd>",
+		oldpvd ? oldpvd->name : "<no pvd>",
+		rt,
+		rt->dst.dev ? rt->dst.dev->name : "",
+		func);
+
+	if (newpvd == oldpvd) {
+		return(0);
+	}
+
+	rcu_read_lock();
+
+	/*
+	 * Remove from oldpvd if present
+	 */
+	if (oldpvd == NULL) {
+		goto Add;
+	}
+
+	for (i = 0; i < oldpvd->nroutes; i++) {
+		if (oldpvd->routes[i] == rt) {
+			/*
+			 * Compact the array
+			 */
+			deltaCount--;
+			for (i++; i < oldpvd->nroutes; i++) {
+				oldpvd->routes[i - 1] = oldpvd->routes[i];
+			}
+			oldpvd->nroutes--;
+			break;
+		}
+	}
+
+	pvd_put(oldpvd);
+
+	rt->rt6i_pvd = NULL;
+
+Add :
+	if (newpvd == NULL) {
+		goto Exit;
+	}
+
+	/*
+	 * Some routes not attached to the interface on which the
+	 * pvd has been received are created => we don't want to
+	 * migrate them to this pvd
+	 */
+	if (rt->dst.dev != newpvd->dev) {
+		rt->rt6i_pvd = NULL;
+		goto Exit;
+	}
+
+	for (i = 0; i < newpvd->nroutes && newpvd->routes[i] != rt; i++);
+
+	if (i >= newpvd->nroutes) {
+		/*
+		 * Not found => create a new entry
+		 */
+		if (newpvd->nroutes >= MAXROUTESPERPVD) {
+			rc = -1;
+			goto Exit;
+		}
+		newpvd->routes[newpvd->nroutes++] = rt;
+		deltaCount++;
+	}
+
+	rt->rt6i_pvd = pvd_hold(newpvd);
+
+Exit :
+#if	0
+	if (deltaCount == -1) {
+		dst_release(&rt->dst);
+	} else
+	if (deltaCount == 1) {
+		dst_hold(&rt->dst);
+	}
+#endif
+
+	/*
+	 * Note that notifications below (pvd_rtnl_notify) may result in
+	 * multiple notifications when routes are deleted (or added)
+	 * The applications may react to each of these notifications by
+	 * requesting the pvd attributes : this is unfortunate. We
+	 * may want to coalesce these notifications (by using a timer
+	 * maybe), or, lazy we are, give the applications some guidelines
+	 * to implement their own timer before requesting the attributes
+	 */
+	if (oldpvd != NULL) {
+		printk("pvd_migrate_route : oldpvd : %d routes present\n",
+			oldpvd->nroutes);
+		pvd_rtnl_notify(oldpvd, PVD_UPDATE);
+	}
+
+	if (newpvd != NULL) {
+		printk("pvd_migrate_route : newpvd : %d routes present\n",
+			newpvd->nroutes);
+		pvd_rtnl_notify(newpvd, PVD_UPDATE);
+	}
+
+	rcu_read_unlock();
+
+	return(rc);
+}
+
+/*
+ * pvd_migrate_addr : some addresses are created from prefixes (via RA)
+ * or manually associated to a pvd. We want to be able to find the pvd
+ * associated to the address and, conversely, find all addresses attached
+ * to a pvd
+ * Addresses can also migrate from one pvd to another one. This function
+ * updates the different links between pvds and addresses
+ * An address associated to no pvd has its ->pvd field == NULL
+ *
+ * A reference is hold on the address on success as well as on the
+ * pvd
+ *
+ * FIXME : check if rtnl_lock() must be taken here ! WARNING :
+ * it seems that we are creating issues when removing an address
+ * and calling pvd_migrate_addr to remove it from its pvd =>
+ * rtnl_lock must certainly already be taken somewhere in the
+ * callers chain => we are using rcu_read_lock()/rcu_read_unlock()
+ * instead
+ */
+/*
+ * pvd_migrate_addr : migrate an address from its current pvd to a new pvd
+ * Its current pvd might be NULL
+ */
+int	pvd_migrate_addr(
+		struct net_pvd *newpvd,
+		struct inet6_ifaddr *ifa)
+{
+	int		i;
+	int		deltaCount = 0;
+	struct net_pvd	*oldpvd;
+	int		rc = 0;
+
+	if (ifa == NULL) {
+		return(0);
+	}
+
+	oldpvd = ifa->pvd;
+
+	printk("pvd_migrate_addr(pvd = %s, oldpvd = %s, ifa = %p) called\n",
+		newpvd ? newpvd->name : "<no pvd>",
+		oldpvd ? oldpvd->name : "<no pvd>",
+		ifa);
+
+	if (newpvd == oldpvd) {
+		return(0);
+	}
+
+	rcu_read_lock();
+
+	/*
+	 * Remove from oldpvd if present
+	 */
+	if (oldpvd == NULL) {
+		goto Add;
+	}
+
+	for (i = 0; i < oldpvd->naddresses; i++) {
+		if (oldpvd->addresses[i] == ifa) {
+			/*
+			 * Compact the array
+			 */
+			deltaCount--;
+			for (i++; i < oldpvd->naddresses; i++) {
+				oldpvd->addresses[i - 1] = oldpvd->addresses[i];
+			}
+			oldpvd->naddresses--;
+			break;
+		}
+	}
+
+	pvd_put(oldpvd);
+
+	ifa->pvd = NULL;
+
+Add :
+	if (newpvd == NULL) {
+		goto Exit;
+	}
+
+	for (i = 0; i < newpvd->naddresses && newpvd->addresses[i] != ifa; i++);
+
+	if (i >= newpvd->naddresses) {
+		/*
+		 * Not found => create a new entry
+		 */
+		if (newpvd->naddresses >= MAXADDRPERPVD) {
+			rc = -1;
+			goto Exit;
+		}
+		newpvd->addresses[newpvd->naddresses++] = ifa;
+		deltaCount++;
+	}
+
+	ifa->pvd = pvd_hold(newpvd);
+
+Exit :
+#if	0
+	if (deltaCount == -1) {
+		in6_ifa_put(ifa);
+	} else
+	if (deltaCount == 1) {
+		in6_ifa_hold(ifa);
+	}
+#endif
+
+	if (oldpvd != NULL) {
+		printk("pvd_migrate_addr : oldpvd : %d addresses present\n",
+			oldpvd->naddresses);
+		pvd_rtnl_notify(oldpvd, PVD_UPDATE);
+	}
+
+	if (newpvd != NULL) {
+		printk("pvd_migrate_addr : newpvd : %d addresses present\n",
+			newpvd->naddresses);
+		pvd_rtnl_notify(newpvd, PVD_UPDATE);
+	}
+
+	rcu_read_unlock();
+
+	return(rc);
+}
+
+/*
+ * pvd_register_rdnss : given a RDNSS option, registers it. This means
+ * checking if each address it defines is already registered. We also
+ * handle a lifetime == 0 to delete RDNSS entries
+ */
+static void pvd_register_one_rdnss(
+			struct net_pvd *pvd,
+			struct in6_addr *ina, 
+			unsigned long lifetime)
+{
+	int i, j;
+
+	for (i = 0; i < pvd->nrdnss; i++) {
+		if (memcmp(&pvd->rdnss[i], ina, sizeof(*ina)) == 0) {
+			/*
+			 * Update its lifetime (or delete it if lifetime == 0)
+			 */
+			if (lifetime == 0) {
+				rdnss_rtnl_notify(pvd, &pvd->rdnss[i], RDNSS_DEL);
+
+				for (j = i + 1; j < pvd->nrdnss; j++) {
+					pvd->rdnssExpire[j - 1] = pvd->rdnssExpire[j];
+					pvd->rdnss[j - 1] = pvd->rdnss[j];
+				}
+				pvd->nrdnss--;
+			}
+			else {
+				pvd->rdnssExpire[i] =
+					lifetime == (unsigned long) 0xFFFFFFFF ?
+						-1UL :
+						jiffies / HZ + lifetime;
+			}
+			return;
+		}
+	}
+
+	if (lifetime == 0) {
+		return;
+	}
+
+	if (pvd->nrdnss < MAXRDNSSPERPVD) {
+		pvd->rdnss[pvd->nrdnss] = *ina;
+		pvd->rdnssExpire[pvd->nrdnss] =
+			lifetime == (unsigned long) 0xFFFFFFFF ?
+				-1UL : 
+				jiffies / HZ + lifetime;
+
+		rdnss_rtnl_notify(pvd, &pvd->rdnss[pvd->nrdnss], RDNSS_NEW);
+
+		pvd->nrdnss++;
+	}
+}
+
+void	pvd_register_rdnss(struct net_pvd *pvd, void *rdnss_opt)
+{
+	struct nd_opt_rdnss_info *rdnssi = (struct nd_opt_rdnss_info *) rdnss_opt;
+	int count = rdnssi->nd_opt_rdnssi_len;
+
+	rcu_read_lock();
+
+	switch (count) {
+		case 7 :
+			pvd_register_one_rdnss(
+					pvd,
+					&rdnssi->nd_opt_rdnssi_addr3,
+					ntohl(rdnssi->nd_opt_rdnssi_lifetime));
+			/* FALLTHROUGH */
+		case 5 :
+			pvd_register_one_rdnss(
+					pvd,
+					&rdnssi->nd_opt_rdnssi_addr2,
+					ntohl(rdnssi->nd_opt_rdnssi_lifetime));
+			/* FALLTHROUGH */
+		case 3 :
+			pvd_register_one_rdnss(
+					pvd,
+					&rdnssi->nd_opt_rdnssi_addr1,
+					ntohl(rdnssi->nd_opt_rdnssi_lifetime));
+			break;
+	}
+
+	rcu_read_unlock();
+}
+
+/*
+ * pvd_register_dnssl : register a DNSSL blob (we should really parse each
+ * FQDN name defined in the option)
+ */
+static void pvd_register_one_dnssl(
+			struct net_pvd *pvd,
+			char *dns_name,
+			unsigned long lifetime)
+{
+	int i, j;
+
+	for (i = 0; i < pvd->ndnssl; i++) {
+		if (strcmp(pvd->dnssl[i], dns_name) == 0) {
+			/*
+			 * Update its lifetime (or delete it if lifetime == 0)
+			 */
+			if (lifetime == 0) {
+				dnssl_rtnl_notify(pvd, pvd->dnssl[i], DNSSL_DEL);
+
+				kfree(pvd->dnssl[i]);
+				for (j = i + 1; j < pvd->ndnssl; j++) {
+					pvd->dnsslExpire[j - 1] = pvd->dnsslExpire[j];
+					pvd->dnssl[j - 1] = pvd->dnssl[j];
+				}
+				pvd->ndnssl--;
+			}
+			else {
+				pvd->dnsslExpire[i] =
+					lifetime == (unsigned long) 0xFFFFFFFF ?
+						-1UL :
+						jiffies / HZ + lifetime;
+			}
+			return;
+		}
+	}
+
+	if (lifetime == 0) {
+		return;
+	}
+
+	if (pvd->ndnssl < MAXDNSSLPERPVD) {
+		if ((pvd->dnssl[pvd->ndnssl] = kstrdup(dns_name, GFP_KERNEL)) == NULL) {
+			return;
+		}
+		pvd->dnsslExpire[pvd->ndnssl] =
+			lifetime == (unsigned long) 0xFFFFFFFF ?
+				-1UL :
+				jiffies / HZ + lifetime;
+
+		dnssl_rtnl_notify(pvd, pvd->dnssl[pvd->ndnssl], DNSSL_NEW);
+
+		pvd->ndnssl++;
+	}
+}
+
+void	pvd_register_dnssl(struct net_pvd *pvd, void *dnssl_opt)
+{
+	struct nd_opt_dnssl_info *dnssli = (struct nd_opt_dnssl_info *) dnssl_opt;
+	int offset;
+	int offset_max = (dnssli->nd_opt_dnssli_len - 1) * 8;
+	char suffix[256];
+
+	suffix[0] = '\0';
+
+	rcu_read_lock();
+
+	for (offset = 0; offset < offset_max;) {
+		int label_len = dnssli->nd_opt_dnssli_suffixes[offset++];
+
+		if (label_len == 0) {
+			/*
+			 * Ignore empty suffixes
+			 */
+			if (suffix[0] == '\0')
+				continue;
+
+			/*
+			 * We have a complete FQDN : register it or update its
+			 * lifetime
+			 */
+			pvd_register_one_dnssl(
+					pvd, 
+					suffix,
+					ntohl(dnssli->nd_opt_dnssli_lifetime));
+
+			suffix[0] = '\0';
+			continue;
+		}
+
+		if ((sizeof(suffix) - strlen(suffix)) < (label_len + 2)) {
+			printk("oversized suffix in DNSSL option\n");
+			break;
+		}
+
+		if (suffix[0] != '\0')
+			strcat(suffix, ".");
+		strncat(suffix,
+			(char *) &dnssli->nd_opt_dnssli_suffixes[offset],
+			label_len);
+		offset += label_len;
+	}
+
+	rcu_read_unlock();
+}
+
+/*
+ * alloc_bound_pvd : allocate a structure large enough to accept
+ * a copy of user parameters defining a set of PvDs to bind to
+ *
+ * It will be called to allocate a structure linked to :
+ * 1) either a socket
+ * 2) either a thread
+ * 3) either a process
+ */
+
+
+/*
+ * release_bound_pvd : release a bound pvd structure
+ */
+
+/*
+ * ref_bound_pvd : add one reference to a bound pvd structure
+ */
+
+/*
+ * unref_bound_pvd : remove one reference to a bound pvd structure
+ * If the refcount reaches 0, the structure is released
+ */
+
+/*
+ * sock_setbindtopvd : a socket can be bound to multiple pvd
+ * The socket option argument is a handle to a pointer and
+ * not a pointer to the actual structure (the bind_to_pvd
+ * structure is too large to be copied on the kernel stack)
+ *
+ * USERLAND ABI
+ */
+int sock_setbindtopvd(
+		struct sock *sk,
+		char __user *optval,
+		int optlen)
+{
+	int ret = -ENOPROTOOPT;
+	struct net *net = sock_net(sk);
+	char pvdname[PVDNAMSIZ];
+	int i;
+	int npvds = 0;
+	int unpvds = 0;
+	struct bind_to_pvd __user *pbtp;
+	int boundpvds[MAXBOUNDPVD];
+
+	ret = -EINVAL;
+	if (optlen < 0) {
+		goto out;
+	}
+
+	/* Bind this socket to a set of pvds, specified in an array
+	 * The pvds are identified (for now) by pvd names
+	 * If the number of pvds is 0 or all pvd ids are invalid,
+	 * the socket is not bound
+	 * If the socket is already bound to pvds, they are replaced
+	 * by the new specification
+	 */
+	if (optlen != sizeof(struct bind_to_pvd *)) {
+		goto out;
+	}
+
+	memset(boundpvds, 0xFF, sizeof(boundpvds));
+
+	ret = -EFAULT;
+	if (copy_from_user(&pbtp, optval, optlen)) {
+		goto out;
+	}
+
+	ret = -EINVAL;
+	get_user(unpvds, &pbtp->npvd);
+	if (unpvds < 0 || unpvds > MAXBOUNDPVD) {
+		goto out;
+	}
+
+	rcu_read_lock();
+	for (i = 0; i < unpvds; i++) {
+		struct net_pvd *pvd;
+		int l = strncpy_from_user(pvdname, pbtp->pvdnames[i], PVDNAMSIZ - 1);
+
+		if (l < 0 || l == PVDNAMSIZ - 1) {
+			ret = l < 0 ? l : -EINVAL;
+			rcu_read_unlock();
+			goto out;
+		}
+		if (l == 0) {
+			continue;	/* empty name : simply ignore it */
+		}
+		if ((pvd = pvd_get_by_name_rcu(net, pvdname, NULL, NULL)) == NULL) {
+			continue;
+		}
+		/* Take one reference on the pvd */
+		pvd_hold(pvd);
+
+		boundpvds[npvds++] = pvd_get_fullindex(pvd);
+	}
+
+	/* Reset any previous bindings */
+	lock_sock(sk);
+
+	for (i = 0; i < sk->sk_n_bound_pvd; i++) {
+		struct net_pvd *pvd;
+
+		if ((pvd = __pvd_get_by_fullindex(
+					net,
+					sk->sk_bound_pvds[i])) != NULL) {
+			pvd_put(pvd);
+		}
+	}
+
+	/* And update the new ones (possibly none) */
+	sk->sk_n_bound_pvd = npvds;
+	memcpy(sk->sk_bound_pvds, boundpvds, sizeof(sk->sk_bound_pvds));
+	sk_dst_reset(sk);
+	release_sock(sk);
+
+	rcu_read_unlock();
+
+	ret = 0;
+
+out:
+	return ret;
+}
+
+int sock_getbindtopvd(
+		struct sock *sk,
+		char __user *optval,
+		int __user *optlen,
+		int len)
+{
+	int ret = -ENOPROTOOPT;
+	struct net *net = sock_net(sk);
+	int boundpvds[DIM(sk->sk_bound_pvds)];
+	struct bind_to_pvd __user *pbtp;
+	int unpvds;
+	int i, n, npvds, l;
+
+	ret = -EINVAL;
+	if (len != sizeof(struct bind_to_pvd *)) {
+		goto out;
+	}
+
+	ret = -EFAULT;
+	if (copy_from_user(&pbtp, optval, len)) {
+		goto out;
+	}
+
+	ret = -EINVAL;
+	get_user(unpvds, &pbtp->npvd);
+	if (unpvds < 0 || unpvds > MAXBOUNDPVD) {	// npvd will be updated
+		goto out;
+	}
+
+	lock_sock(sk);
+
+	npvds = sk->sk_n_bound_pvd;
+	memcpy(boundpvds, sk->sk_bound_pvds, sizeof(sk->sk_bound_pvds));
+
+	release_sock(sk);
+
+	rcu_read_lock();
+	for (n = 0, i = 0; i < npvds && i < unpvds; i++) {
+		struct net_pvd *pvd;
+
+		if ((pvd = __pvd_get_by_fullindex(net, boundpvds[i])) != NULL) {
+			if ((l = strlen(pvd->name)) > PVDNAMSIZ -1) {
+				l = PVDNAMSIZ - 1;
+			}
+			ret = -EFAULT;
+			if (copy_to_user(pbtp->pvdnames[n],
+					 pvd->name, l + 1)) {
+				rcu_read_unlock();
+				goto out;
+			}
+			n++;
+		}
+	}
+	put_user(n, &pbtp->npvd);
+
+	rcu_read_unlock();
+
+	ret = 0;
+out :
+	return ret;
+}
+
+/*
+ * _sock_getpvdattr : fill in a user net_pvd_attribute structure
+ * Called by both sock_getpvdlist (returns the attributes for all
+ * the PvD) and sock_getpvdattr (returns the attributes for one given
+ * PvD)
+ */
+static int _sock_getpvdattr(
+		struct net_pvd *pvd, 
+		struct net_pvd_attribute *pvdattr)
+{
+static	char	lNullDevName[IFNAMSIZ] = { 0 };
+	int	l;
+	int	i;
+	int	ret;
+
+	/*
+	 * First, the attributes extracted from the
+	 * pvd option header
+	 */
+	if ((l = strlen(pvd->name)) > PVDNAMSIZ -1) {
+		l = PVDNAMSIZ - 1;
+	}
+	ret = -EFAULT;
+	if (copy_to_user(pvdattr->name, pvd->name, l + 1)) {
+		goto out;
+	}
+	put_user(pvd->sequence_number, &pvdattr->sequence_number);
+	put_user(pvd->h_flag, &pvdattr->h_flag);
+	put_user(pvd->l_flag, &pvdattr->l_flag);
+	put_user(pvd_get_fullindex(pvd), &pvdattr->index);
+	put_user(pvd->implicit_flag, &pvdattr->implicit_flag);
+
+	/*
+	 * Now, the attributes induced from the RA carrying this PvD
+	 *
+	 * Receiving interface (eg eth0)
+	 * LLA of the router
+	 * Addresses allocated from prefixes
+	 * Routes
+	 * User options :
+	 * 	DNSSL
+	 * 	RDNSS
+	 */
+	if (copy_to_user(&pvdattr->lla, &pvd->lla, sizeof(pvdattr->lla))) {
+		goto out;
+	}
+
+	if (copy_to_user(
+			&pvdattr->dev,
+			pvd->dev ? pvd->dev->name : lNullDevName, IFNAMSIZ)) {
+		goto out;
+	}
+
+	put_user(pvd->naddresses, &pvdattr->naddresses);
+	for (i = 0; i < pvd->naddresses; i++) {
+		if (copy_to_user(
+			&pvdattr->addresses[i],
+			&pvd->addresses[i]->addr,
+			sizeof(pvdattr->addresses[i]))) {
+				goto out;
+		}
+		put_user(
+			pvd->addresses[i]->prefix_len,
+			&pvdattr->addr_prefix_len[i]);
+	}
+
+	/*
+	 * The routes
+	 */
+	put_user(pvd->nroutes, &pvdattr->nroutes);
+	for (i = 0; i < pvd->nroutes; i++) {
+		struct in6_addr NullAddr;
+
+		struct rt6_info *rt = pvd->routes[i];
+		struct net_pvd_route *urt = &pvdattr->routes[i];
+
+		memset(&NullAddr, 0, sizeof(NullAddr));
+
+		if (copy_to_user(
+			&urt->dst,
+			&rt->rt6i_dst.addr,
+			sizeof(urt->dst))) {
+			goto out;
+		}
+
+		if (copy_to_user(
+			&urt->gateway,
+			(rt->rt6i_flags & RTF_GATEWAY) ?
+				&rt->rt6i_gateway :
+				&NullAddr,
+			sizeof(urt->gateway))) {
+			goto out;
+		}
+
+		if (copy_to_user(
+			urt->dev_name,
+			rt->dst.dev ? rt->dst.dev->name : lNullDevName, IFNAMSIZ)) {
+			goto out;
+		}
+	}
+
+	/*
+	 * The RDNSS/DNSSL attributes
+	 */
+	put_user(pvd->nrdnss, &pvdattr->nrdnss);
+	for (i = 0; i < pvd->nrdnss; i++) {
+		if (copy_to_user(
+				&pvdattr->rdnss[i],
+				&pvd->rdnss[i],
+				sizeof(pvdattr->rdnss[i]))) {
+			goto out;
+		}
+	}
+
+	put_user(pvd->ndnssl, &pvdattr->ndnssl);
+	for (i = 0; i < pvd->ndnssl; i++) {
+		if ((l = strlen(pvd->dnssl[i])) > FQDNSIZ) {
+			goto out;
+		}
+		if (copy_to_user(
+				pvdattr->dnssl[i],
+				pvd->dnssl[i],
+				l + 1)) {
+			goto out;
+		}
+	}
+
+	ret = 0;
+
+out :
+	return ret;
+}
+
+/*
+ * sock_createpvd : create/update a pvd with some attributes
+ * When creating a PvD, fields not specified receive a default
+ * value. When updating a PvD, only those specified in the flag
+ * field are updated
+ *
+ * USERLAND ABI
+ */
+int sock_createpvd(
+		struct sock *sk,
+		char __user *optval,
+		int optlen)
+{
+	int ret = -ENOPROTOOPT;
+	struct net *net = sock_net(sk);
+	struct create_pvd cpvd;
+	struct net_pvd *pvd;
+	int pvdJustCreated = false;
+
+	if (! ns_capable(net->user_ns, CAP_NET_ADMIN))
+		return -EPERM;
+
+	if (optlen != sizeof(struct create_pvd)) {
+		return -EINVAL;
+	}
+
+	if (copy_from_user(&cpvd, optval, optlen)) {
+		return -EFAULT;
+	}
+
+	if (cpvd.pvdname[0] == '\0') {
+		return -EINVAL;	/* empty name */
+	}
+
+	rtnl_lock();
+
+	for (pvd = net->first_used_pvd;
+	     pvd != NULL && strcmp(pvd->name, cpvd.pvdname) != 0;
+	     pvd = pvd->next);
+
+	ret = 0;
+
+	/*
+	 * if PvD non existent => create it if deprecated != 1
+	 */
+	if (pvd == NULL) {
+		if ((cpvd.flag & PVD_ATTR_DEPRECATED) != 0 && cpvd.deprecated == 1) {
+			goto out;
+		}
+
+		if ((pvd = __register_pvd(net, cpvd.pvdname, NULL, NULL)) == NULL) {
+			ret = -ENOMEM;
+			goto out;
+		}
+		pvdJustCreated = true;
+	}
+
+	if ((cpvd.flag & PVD_ATTR_DEPRECATED) != 0 && cpvd.deprecated == 1) {
+		__unregister_pvd(pvd);
+		goto out;
+	}
+
+	rcu_read_lock();
+
+	if ((cpvd.flag & PVD_ATTR_SEQNUMBER) != 0) {
+		pvd->sequence_number = cpvd.sequence_number;
+	}
+
+	if ((cpvd.flag & PVD_ATTR_HFLAG) != 0) {
+		pvd->h_flag = cpvd.h_flag;
+	}
+
+	if ((cpvd.flag & PVD_ATTR_LFLAG) != 0) {
+		pvd->l_flag = cpvd.l_flag;
+	}
+
+	rcu_read_unlock();
+
+	if (cpvd.flag != 0 || pvdJustCreated) {
+		pvd_rtnl_notify(pvd, pvdJustCreated ? PVD_NEW : PVD_UPDATE);
+	}
+out :
+	rtnl_unlock();
+
+	return ret;
+}
+
+/*
+ * sock_getpvdattr : return the attributes for a given PvD
+ *
+ * USERLAND ABI
+ */
+int sock_getpvdattr(
+		struct sock *sk,
+		char __user *optval,
+		int __user *optlen,
+		int len)
+{
+	int ret = -ENOPROTOOPT;
+	struct net *net = sock_net(sk);
+	struct pvd_attr pva;
+	char pvdname[PVDNAMSIZ];
+	struct net_pvd *pvd;
+	int l;
+
+	if (len != sizeof(struct pvd_attr)) {
+		return -EINVAL;
+	}
+
+	if (copy_from_user(&pva, optval, len)) {
+		return -EFAULT;
+	}
+
+	l = strncpy_from_user(pvdname, pva.pvdname, PVDNAMSIZ - 1);
+
+	if (l < 0 || l == PVDNAMSIZ - 1) {
+		return l < 0 ? l : -EINVAL;
+	}
+
+	if (l == 0) {
+		return -EINVAL;	/* empty name */
+	}
+
+	rtnl_lock();
+
+	for (pvd = net->first_used_pvd;
+	     pvd != NULL && strcmp(pvd->name, pvdname) != 0;
+	     pvd = pvd->next);
+
+	ret = pvd ? _sock_getpvdattr(pvd, pva.pvdattr) : -ENOENT;
+
+	rtnl_unlock();
+
+	return ret;
+}
+
+/*
+ * sock_getpvdlist : return the full list of currently registered
+ * pvds, with their attributes
+ *
+ * USERLAND ABI
+ */
+int sock_getpvdlist(
+		struct sock *sk,
+		char __user *optval,
+		int __user *optlen,
+		int len)
+{
+	int ret = -ENOPROTOOPT;
+	struct net *net = sock_net(sk);
+	struct pvd_list __user *pvl;
+	struct net_pvd *pvd;
+	int npvds = 0, unpvds;
+	int l;
+
+	ret = -EINVAL;
+	if (len != sizeof(struct pvd_list *)) {
+		return ret;
+	}
+
+	ret = -EFAULT;
+	if (copy_from_user(&pvl, optval, len)) {
+		return ret;
+	}
+
+	ret = -EINVAL;
+	get_user(unpvds, &pvl->npvd);
+	if (unpvds < 0 || unpvds > MAXPVD) {
+		return ret;
+	}
+
+	rtnl_lock();
+
+	for (npvds = 0, pvd = net->first_used_pvd;
+	     pvd != NULL && npvds < unpvds && npvds < MAXPVD;
+	     pvd = pvd->next, npvds++) {
+		if ((l = strlen(pvd->name)) > PVDNAMSIZ -1) {
+			l = PVDNAMSIZ - 1;
+		}
+		if (copy_to_user(pvl->pvds[npvds], pvd->name, l + 1)) {
+			ret = -EFAULT;
+			goto out;
+		}
+	}
+
+	put_user(npvds, &pvl->npvd);
+
+	ret = 0;
+
+out :
+	rtnl_unlock();
+
+	return ret;
+}
+
+/*
+ * Add a PvD in the per net/array. rtnl must be taken
+ * We have already checked that there was at least
+ * one free slot. On 1st PvD insertion, we arm a timer
+ * that will fire every second
+ */
+static void add_pvd_in_net(struct net_pvd *pvd)
+{
+	struct net *net = pvd_net(pvd);
+	int next_free;
+
+	ASSERT_RTNL();
+
+	write_lock_bh(&pvd_base_lock);
+
+	if (net->first_used_pvd != NULL) {
+		mod_timer(&net->pvd_timer, jiffies + HZ);
+	}
+
+	next_free = net->pvd_free_slots[net->first_free_pvd_ix];
+
+	pvd->next = net->first_used_pvd;
+	pvd->_index = net->first_free_pvd_ix;	/* link back */
+
+	net->pvd_used_slots[net->first_free_pvd_ix] = net->first_used_pvd = (void *) pvd;
+
+	net->first_free_pvd_ix = next_free;
+
+	write_unlock_bh(&pvd_base_lock);
+}
+
+/* Remove a PvD from the per net/array. rtnl must be taken */
+void remove_pvd_from_net(struct net_pvd *pvd)
+{
+	struct net *net = pvd_net(pvd);
+	struct net_pvd *_pvd, *prev;
+
+	ASSERT_RTNL();
+
+	/*
+	 * reset the entry from the per-net pvds array
+	 * and update the first_free/first_used fields
+	 */
+	write_lock_bh(&pvd_base_lock);
+
+	if (pvd->_index < 0 || pvd->_index >= MAXPVD) {
+		// Corruption
+		goto Exit;
+	}
+
+	for (_pvd = net->first_used_pvd, prev = NULL;
+	     _pvd != NULL && _pvd != pvd;
+	     prev = _pvd, _pvd = _pvd->next);
+
+	if (_pvd == NULL) {
+		// Not found in the list : internal error probably
+		goto Exit;
+	}
+	if (prev != NULL) {
+		prev->next = _pvd->next;
+	}
+	else {
+		net->first_used_pvd = _pvd->next;
+	}
+
+	net->pvd_free_slots[pvd->_index] = net->first_free_pvd_ix;
+	net->first_free_pvd_ix = pvd->_index;
+
+	net->pvd_used_slots[pvd->_index] = NULL;
+	pvd->_index = -1;
+
+Exit :
+	write_unlock_bh(&pvd_base_lock);
+}
+
+/**
+ * 	pvd_get_fullindex	- return the full index of a pvd
+ * 	@pvd : a pvd (retrieved by name or else)
+ *
+ * 	Given the pvd, build the full index that can be used
+ * 	for future safe retrieval of the pvd
+ * 	The full index combines an index (in the net->pvd_used_slots
+ * 	array) and the uniquely generated pvdindex
+ *
+ * 	The rntl semaphore mut be taken
+ */
+
+int pvd_get_fullindex(struct net_pvd *pvd)
+{
+	return pvd->_index | (pvd->pvdindex << MAXPVDSHIFT);
+}
+
+/**
+ *	__pvd_get_by_name	- find a pvd by its name
+ *	@net: the applicable net namespace
+ *	@name: name to find (authoritative if non NULL)
+ *	@dev: in a RA context, interface the RA has been received
+ *	@lla: in a RA context, lla of the router
+ *
+ *	Find a pvd by name. Must be called under RTNL semaphore
+ *	or @pvd_base_lock. If the name is found a pointer to the pvd
+ *	is returned. If the name is not found then %NULL is returned. The
+ *	reference counters are not incremented so the caller must be
+ *	careful with locks.
+ */
+
+struct net_pvd *__pvd_get_by_name(
+			struct net *net,
+			const char *name,
+			struct net_device *dev,
+			struct in6_addr *lla)
+{
+	struct in6_addr NullAddr;
+	struct net_pvd *pvd = net->first_used_pvd;
+
+	/*
+	 * If the name is specified, simple string comparison
+	 * pvd->name always contains something (even for implicit
+	 * pvd)
+	 */
+	if (name != NULL) {
+		for (pvd = net->first_used_pvd; pvd != NULL; pvd = pvd->next) {
+			if (strncmp(pvd->name, name, PVDNAMSIZ) == 0) {
+				return pvd;
+			}
+		}
+		return NULL;
+	}
+
+	/*
+	 * Name == NULL. Consider the lla and the interface
+	 */
+	memset(&NullAddr, 0, sizeof(NullAddr));
+
+	if (lla == NULL) {
+		lla = &NullAddr;
+	}
+
+	for (pvd = net->first_used_pvd; pvd != NULL; pvd = pvd->next) {
+		if (dev != NULL && pvd->dev == NULL) {
+			continue;
+		}
+		if (dev == NULL && pvd->dev != NULL) {
+			continue;
+		}
+		if (pvd->dev == dev &&
+		    memcmp(lla, &pvd->lla, sizeof(*lla)) == 0) {
+			return pvd;
+		}
+	}
+	return NULL;
+}
+EXPORT_SYMBOL(__pvd_get_by_name);
+
+/**
+ *	pvd_get_by_name_rcu	- find a pvd by its name
+ *	@net: the applicable net namespace
+ *	@name: name to find
+ *
+ *	Find an pvd by name.
+ *	If the name is found a pointer to the pvd is returned.
+ * 	If the name is not found then %NULL is returned.
+ *	The reference counters are not incremented so the caller must be
+ *	careful with locks. The caller must hold RCU lock.
+ */
+
+struct net_pvd *pvd_get_by_name_rcu(
+			struct net *net,
+			const char *name,
+			struct net_device *dev,
+			struct in6_addr *lla)
+{
+	return __pvd_get_by_name(net, name, dev, lla);
+}
+EXPORT_SYMBOL(pvd_get_by_name_rcu);
+
+/**
+ *	pvd_get_by_name		- find a pvd by its name
+ *	@net: the applicable net namespace
+ *	@name: name to find
+ *
+ *	Find an pvd by name. This can be called from any
+ *	context and does its own locking. The returned handle has
+ *	the usage count incremented and the caller must use pvd_put() to
+ *	release it when it is no longer needed. %NULL is returned if no
+ *	matching pvd is found.
+ */
+
+struct net_pvd *pvd_get_by_name(
+			struct net *net,
+			const char *name,
+			struct net_device *dev,
+			struct in6_addr *lla)
+{
+	struct net_pvd *pvd;
+
+	rcu_read_lock();
+	pvd = pvd_get_by_name_rcu(net, name, dev, lla);
+	if (pvd)
+		pvd_hold(pvd);
+	rcu_read_unlock();
+	return pvd;
+}
+EXPORT_SYMBOL(pvd_get_by_name);
+
+/**
+ *	__pvd_get_by_fullindex - find a pvd by its full pvdindex
+ *	@net: the applicable net namespace
+ *	@fullindex: index of pvd
+ *
+ *	Search for a pvd given a fullindex. A full index is built from
+ *	2 part : one which is an index in the net->pvds array and a part
+ *	which is a unique allocated number. Such a full index must have
+ *	been grabbed earlier, given a pvd name for example.
+ *	
+ *	Returns %NULL if the pvd is not found or not valid or a pointer to
+ *	the pvd. The pvd has not had its reference counter increased so the
+ *	caller must be careful about locking. The caller must hold either
+ *	the RTNL semaphore or @pvd_base_lock.
+ */
+
+struct net_pvd *__pvd_get_by_fullindex(struct net *net, int fullindex)
+{
+	struct net_pvd *pvd;
+	int _index = _TABIDX(fullindex);
+	u32 pvdindex = _UNIQIDX(fullindex);
+
+	if (_index < 0 || _index >= MAXPVD) {	// >= MAXPVD is not possible
+		return NULL;
+	}
+	if ((pvd = net->pvd_used_slots[_index]) == NULL) {
+		return NULL;
+	}
+	if (pvd->pvdindex != pvdindex && pvd->_index != _index) {
+		return NULL;
+	}
+	return pvd;
+}
+EXPORT_SYMBOL(__pvd_get_by_fullindex);
+
+/**
+ *	__pvd_get_by_index - find a pvd by its pvdindex
+ *	@net: the applicable net namespace
+ *	@pvdindex: index of pvd
+ *
+ *	Search for a pvd by index. Returns %NULL if the pvd
+ *	is not found or a pointer to the pvd. The pvd has not
+ *	had its reference counter increased so the caller must be careful
+ *	about locking. The caller must hold either the RTNL semaphore
+ *	or @pvd_base_lock.
+ */
+
+struct net_pvd *__pvd_get_by_index(struct net *net, u32 pvdindex)
+{
+	struct net_pvd *pvd = net->first_used_pvd;
+
+	while (pvd != NULL && pvd->pvdindex != pvdindex) {
+		pvd = pvd->next;
+	}
+	return pvd;
+}
+EXPORT_SYMBOL(__pvd_get_by_index);
+
+/**
+ *	pvd_get_by_index_rcu - find a pvd by its pvdindex
+ *	@net: the applicable net namespace
+ *	@ifindex: index of pvd
+ *
+ *	Search for an interface by index. Returns %NULL if the pvd
+ *	is not found or a pointer to the pvd. The pvd has not
+ *	had its reference counter increased so the caller must be careful
+ *	about locking. The caller must hold RCU lock.
+ */
+
+struct net_pvd *pvd_get_by_index_rcu(struct net *net, u32 pvdindex)
+{
+	return __pvd_get_by_index(net, pvdindex);
+}
+EXPORT_SYMBOL(pvd_get_by_index_rcu);
+
+/**
+ *	pvd_get_by_index - find a pvd by its pvdindex
+ *	@net: the applicable net namespace
+ *	@pvdindex: index of pvd
+ *
+ *	Search for a pvd by index. Returns NULL if the pvd
+ *	is not found or a pointer to the pvd. The pvd returned has
+ *	had a reference added and the pointer is safe until the user calls
+ *	pvd_put to indicate they have finished with it.
+ */
+
+struct net_pvd *pvd_get_by_index(struct net *net, int pvdindex)
+{
+	struct net_pvd *pvd;
+
+	rcu_read_lock();
+	pvd = pvd_get_by_index_rcu(net, pvdindex);
+	if (pvd)
+		pvd_hold(pvd);
+	rcu_read_unlock();
+	return pvd;
+}
+EXPORT_SYMBOL(pvd_get_by_index);
+
+/**
+ *	netpvd_get_name - get a pvd name, knowing its pvdindex.
+ *	@net: network namespace
+ *	@pvdname: a pointer to the buffer where the name will be stored.
+ *	@pvdindex: the pvdindex of the pvd to get the name from.
+ *
+ *	The use of raw_seqcount_begin() and cond_resched() before
+ *	retrying is required as we want to give the writers a chance
+ *	to complete when CONFIG_PREEMPT is not set.
+ */
+int netpvd_get_name(struct net *net, char *pvdname, u32 pvdindex)
+{
+	struct net_pvd *pvd;
+	unsigned int seq;
+
+retry:
+	seq = raw_seqcount_begin(&pvd_rename_seq);
+	rcu_read_lock();
+	pvd = pvd_get_by_index_rcu(net, pvdindex);
+	if (!pvd) {
+		rcu_read_unlock();
+		return -ENODEV;
+	}
+
+	strcpy(pvdname, pvd->name);
+	rcu_read_unlock();
+	if (read_seqcount_retry(&pvd_rename_seq, seq)) {
+		cond_resched();
+		goto retry;
+	}
+
+	return 0;
+}
+
+/**
+ *	pvd_new_index	-	allocate a pvdindex
+ *	@net: the applicable net namespace
+ *
+ *	Returns a suitable unique value for a new pvd
+ *	number.  The caller must hold the rtnl semaphore or the
+ *	pvd_base_lock to be sure it remains unique.
+ */
+static u32 pvd_new_index(struct net *net)
+{
+	u32	pvdindex = net->pvdindex;
+
+	if (pvdindex >= MAXPVDINDEX) {
+		pvdindex = 0;
+	}
+
+	for (;;) {
+		if (++pvdindex >= MAXPVDINDEX) {
+			pvdindex = 0;
+		}
+
+		if (!__pvd_get_by_index(net, pvdindex))
+			return(net->pvdindex = pvdindex);
+	}
+}
+
+/**
+ *	__register_pvd	-	register a PvD
+ *	@net: the applicable net namespace
+ *	@pvdname: the requested name. Can be NULL in case of implicit PvD
+ *	@dev: the interface associated to the PvD (can be NULL in case of static
+ *	registration)
+ *	@lla: the router lla (can be NULL in case of static registration)
+ */
+static	struct net_pvd	*__register_pvd(
+				struct net *net,
+				char *pvdname,
+				struct net_device *dev,
+				struct in6_addr *lla)
+{
+	struct net_pvd *pvd;
+	int FlagImplicit = false;
+
+	if (pvdname == NULL && (dev == NULL || lla == NULL)) {
+		return(NULL);
+	}
+
+	if (pvdname != NULL && strlen(pvdname) >= PVDNAMSIZ - 1) {
+		return(NULL);
+	}
+
+	/*
+	 * Check for implicit PvD => we create an implicit name
+	 */
+	if (pvdname == NULL) {
+		char sPvdName[PVDNAMSIZ];
+		char sAddr[64];
+
+		sprintf(sPvdName, "%s%%%s", addrtostr(lla, sAddr), dev->name);
+		pvdname = sPvdName;
+		FlagImplicit = true;
+	}
+
+	printk("__register_pvd called: %s\n", pvdname);
+
+	if ((pvd = pvd_get_by_name(net, pvdname, dev, lla)) != NULL) {
+		return(pvd);
+	}
+
+	/*
+	 * Check if not already too many pvds defined
+	 */
+	if (net->first_free_pvd_ix == -1) {
+		return(NULL);
+	}
+
+	/*
+	 * Not existing : create a new one
+	 */
+	if ((pvd = kzalloc(
+			sizeof(*pvd),
+			GFP_KERNEL | __GFP_NOWARN | __GFP_REPEAT)) == NULL) {
+		return(NULL);
+	}
+	strcpy(pvd->name, pvdname);
+	pvd->pvdindex = pvd_new_index(net);
+	pvd->_index = -1;	/* index in the net->pvds array */
+	pvd_net_set(pvd, net);
+	pvd->dev = dev;
+	pvd->implicit_flag = FlagImplicit;
+	if (lla != NULL) {
+		memcpy(&pvd->lla, lla, sizeof(*lla));
+	}
+	if (dev != NULL) {
+		dev_hold(dev);
+	}
+
+	pvd->pcpu_refcnt = alloc_percpu(int);
+
+	if (! pvd->pcpu_refcnt) {
+		goto free_pvd;
+	}
+
+	add_pvd_in_net(pvd);	/* this should update pvd->index */
+
+	/*
+	 * The other fields will be initialized later
+	 */
+
+#ifdef CONFIG_PROC_FS
+	register_proc_pvd(net, pvd);
+#endif
+	return(pvd);
+
+free_pvd :
+	kvfree((char *) pvd);
+
+	return(NULL);
+}
+
+struct net_pvd	*register_pvd(
+			struct net *net,
+			char *pvdname,
+			struct net_device *dev,
+			struct in6_addr *lla)
+{
+	struct net_pvd	*pvd;
+
+	rtnl_lock();
+	pvd = __register_pvd(net, pvdname, dev, lla);
+	rtnl_unlock();
+	return pvd;
+}
+
+/*
+ * TODO : provide and implement a unregister_pvd function
+ * We should disconnect from the associated addresses, sockets
+ * and routes
+ */
+static void __unregister_pvd(struct net_pvd *pvd)
+{
+	int	i;
+
+	printk("unregister_pvd(%s) called\n", pvd ? pvd->name : "<no pvd>");
+	
+	if (pvd) {
+#ifdef CONFIG_PROC_FS
+		unregister_proc_pvd(pvd_net(pvd), pvd);
+#endif
+		rcu_read_lock();
+
+		pvd_rtnl_notify(pvd, PVD_DEL);
+
+		if (pvd->pcpu_refcnt) {
+			free_percpu(pvd->pcpu_refcnt);
+		}
+		/*
+		 * Deassociate the pvd from its addresses and routes
+		 */
+		for (i = 0; i < pvd->nroutes; i++) {
+			if (pvd->routes[i]->rt6i_pvd == pvd) {	/* consistency check */
+				pvd->routes[i]->rt6i_pvd = NULL;
+			}
+		}
+
+		for (i = 0; i < pvd->naddresses; i++) {
+			if (pvd->addresses[i]->pvd == pvd) {	/* consistency check */
+				pvd->addresses[i]->pvd = NULL;
+			}
+		}
+
+		/*
+		 * Free the duplicate payloads for the RDNSS and DNSSL options
+		 */
+		for (i = 0; i < pvd->ndnssl; i++) {
+			kfree(pvd->dnssl[i]);
+		}
+
+		/*
+		 * TODO : Deassociate from the bound sockets
+		 */
+
+		rcu_read_unlock();
+
+		/*
+		 * Remove it from the net structure
+		 */
+		remove_pvd_from_net(pvd);
+
+		kvfree((char *) pvd);
+	}
+}
+
+/*
+ * pvd_check_lifetimes : timer callback checking expired rdnss/dnssl
+ * attached to registered pvds
+ */
+static void pvd_check_lifetimes(unsigned long arg)
+{
+	struct net *net = (struct net *) arg;
+	struct net_pvd *pvd, *pvdnext = NULL;
+	unsigned long now = jiffies / HZ;
+	int FlagUpdate;
+	int i, j;
+
+	rtnl_lock();
+
+	for (pvd = net->first_used_pvd; pvd; pvd = pvdnext) {
+		pvdnext = pvd->next;
+
+		rcu_read_lock();
+
+		FlagUpdate = false;
+
+		for (i = 0; i < pvd->ndnssl; i++) {
+			if (pvd->dnsslExpire[i] != -1UL &&
+					pvd->dnsslExpire[i] <= now) {
+				FlagUpdate = true;
+
+				dnssl_rtnl_notify(pvd, pvd->dnssl[i], DNSSL_DEL);
+
+				kfree(pvd->dnssl[i]);
+				for (j = i + 1; j < pvd->ndnssl; j++) {
+					pvd->dnsslExpire[j - 1] = pvd->dnsslExpire[j];
+					pvd->dnssl[j - 1] = pvd->dnssl[j];
+				}
+				pvd->ndnssl--;
+			}
+		}
+
+		for (i = 0; i < pvd->nrdnss; i++) {
+			if (pvd->rdnssExpire[i] != -1UL &&
+					pvd->rdnssExpire[i] <= now) {
+				FlagUpdate = true;
+
+				rdnss_rtnl_notify(pvd, &pvd->rdnss[i], RDNSS_DEL);
+
+				for (j = i + 1; j < pvd->nrdnss; j++) {
+					pvd->rdnssExpire[j - 1] = pvd->rdnssExpire[j];
+					pvd->rdnss[j - 1] = pvd->rdnss[j];
+				}
+				pvd->nrdnss--;
+			}
+		}
+
+		if (FlagUpdate) {
+			pvd_rtnl_notify(pvd, PVD_UPDATE);
+		}
+		rcu_read_unlock();
+	}
+
+	/*
+	 * We rearm the timer for one more second if there are
+	 * some pvd still registered
+	 */
+	if (net->first_used_pvd != NULL) {
+		mod_timer(&net->pvd_timer, jiffies + HZ);
+	}
+	rtnl_unlock();
+}
+
+void unregister_pvd(struct net_pvd *pvd)
+{
+	rtnl_lock();
+	__unregister_pvd(pvd);
+	rtnl_unlock();
+}
+
+/*
+ *	Initialize the PVD module
+ *       This is called single threaded during boot, so no need
+ *       to take the rtnl semaphore.
+ */
+static int pvd_boot_phase = 1;
+
+static int __init net_pvd_init(void)
+{
+	int rc = -ENOMEM;
+
+	BUG_ON(!pvd_boot_phase);
+
+	if (register_pernet_subsys(&netpvd_net_ops))
+		goto out;
+
+#ifdef CONFIG_PROC_FS
+	if (register_pernet_subsys(&netpvd_proc_ops))
+		goto out;
+#endif
+
+	pvd_boot_phase = 0;
+
+	rc = 0;
+out:
+	return rc;
+}
+
+subsys_initcall(net_pvd_init);
+
+#endif	/* CONFIG_NETPVD */
+
diff -Naur -X DiffNaurExclude ubuntu-4.10.0-orig/net/core/sock.c ubuntu-4.10.0/net/core/sock.c
--- ubuntu-4.10.0-orig/net/core/sock.c	2017-08-10 11:05:24.289046482 +0100
+++ ubuntu-4.10.0/net/core/sock.c	2017-07-31 14:34:18.336687750 +0100
@@ -106,6 +106,10 @@
 #include <linux/string.h>
 #include <linux/sockios.h>
 #include <linux/net.h>
+#ifdef	CONFIG_NETPVD
+#include <net/pvd.h>
+#include <net/ip6_route.h>
+#endif
 #include <linux/mm.h>
 #include <linux/slab.h>
 #include <linux/interrupt.h>
@@ -671,6 +675,13 @@
 	if (optname == SO_BINDTODEVICE)
 		return sock_setbindtodevice(sk, optval, optlen);
 
+#ifdef	CONFIG_NETPVD
+	if (optname == SO_BINDTOPVD)
+		return sock_setbindtopvd(sk, optval, optlen);
+	if (optname == SO_CREATEPVD)
+		return sock_createpvd(sk, optval, optlen);
+#endif
+
 	if (optlen < sizeof(int))
 		return -EINVAL;
 
@@ -1238,6 +1249,21 @@
 	case SO_BINDTODEVICE:
 		return sock_getbindtodevice(sk, optval, optlen, len);
 
+#ifdef	CONFIG_NETPVD
+	case SO_BINDTOPVD:
+		return sock_getbindtopvd(sk, optval, optlen, len);
+	case SO_GETPVDLIST:
+		/* This one is not tied to the socket per se,
+		 * but we use the socket as a channel to the
+		 * kernel. FIXME : use the netlink channel instead
+		 * or the ioctl() way of ifreq
+		 */
+		return sock_getpvdlist(sk, optval, optlen, len);
+	case SO_GETPVDATTRIBUTES:
+		/* Same remark as for SO_GETPVDLIST */
+		return sock_getpvdattr(sk, optval, optlen, len);
+#endif
+
 	case SO_GET_FILTER:
 		len = sk_get_filter(sk, (struct sock_filter __user *)optval, len);
 		if (len < 0)
@@ -2515,6 +2541,10 @@
 	sk->sk_ll_usec		=	sysctl_net_busy_read;
 #endif
 
+#ifdef	CONFIG_NET_PVD
+	sk->sk_n_bound_pvd	=	-1;	/* no bindings defined yet */
+#endif
+
 	sk->sk_max_pacing_rate = ~0U;
 	sk->sk_pacing_rate = ~0U;
 	sk->sk_incoming_cpu = -1;
diff -Naur -X DiffNaurExclude ubuntu-4.10.0-orig/net/ipv6/addrconf.c ubuntu-4.10.0/net/ipv6/addrconf.c
--- ubuntu-4.10.0-orig/net/ipv6/addrconf.c	2017-08-10 11:05:24.289046482 +0100
+++ ubuntu-4.10.0/net/ipv6/addrconf.c	2017-08-28 17:19:32.720155756 +0100
@@ -80,6 +80,11 @@
 #include <net/tcp.h>
 #include <net/ip.h>
 #include <net/netlink.h>
+
+#ifdef	CONFIG_NETPVD
+#include <net/pvd.h>
+#endif
+
 #include <net/pkt_sched.h>
 #include <net/l3mdev.h>
 #include <linux/if_tunnel.h>
@@ -107,6 +112,21 @@
 #define IPV6_MAX_STRLEN \
 	sizeof("ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255")
 
+static char *addrtostr(struct in6_addr const *addr, char *str)
+{
+	sprintf(str,
+		"%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x",
+		addr->s6_addr[0], addr->s6_addr[1],
+		addr->s6_addr[2], addr->s6_addr[3],
+		addr->s6_addr[4], addr->s6_addr[5],
+		addr->s6_addr[6], addr->s6_addr[7],
+		addr->s6_addr[8], addr->s6_addr[9],
+		addr->s6_addr[10], addr->s6_addr[11],
+		addr->s6_addr[12], addr->s6_addr[13],
+		addr->s6_addr[14], addr->s6_addr[15]);
+	return(str);
+}
+
 static inline u32 cstamp_delta(unsigned long cstamp)
 {
 	return (cstamp - INITIAL_JIFFIES) * 100UL / HZ;
@@ -906,6 +926,11 @@
 	}
 	ip6_rt_put(ifp->rt);
 
+#ifdef	CONFIG_NETPVD
+	printk("inet6_ifa_finish_destroy called\n");
+	pvd_migrate_addr(NULL, ifp);
+#endif
+
 	kfree_rcu(ifp, rcu);
 }
 
@@ -939,7 +964,9 @@
 static struct inet6_ifaddr *
 ipv6_add_addr(struct inet6_dev *idev, const struct in6_addr *addr,
 	      const struct in6_addr *peer_addr, int pfxlen,
-	      int scope, u32 flags, u32 valid_lft, u32 prefered_lft)
+	      int scope, u32 flags, u32 valid_lft, u32 prefered_lft,
+	      void *pvd,
+	      const char *caller)
 {
 	struct inet6_ifaddr *ifa = NULL;
 	struct rt6_info *rt;
@@ -947,6 +974,17 @@
 	int err = 0;
 	int addr_type = ipv6_addr_type(addr);
 
+#ifdef	CONFIG_NETPVD
+	{
+		char sAddr[64];
+
+		printk("ipv6_add_addr(pvd = %s, addr = %s, %s) called\n",
+			pvd ? ((struct net_pvd *) pvd)->name : "<no pvd>",
+			addrtostr(addr, sAddr),
+			idev->dev->name);
+	}
+#endif
+
 	if (addr_type == IPV6_ADDR_ANY ||
 	    addr_type & IPV6_ADDR_MULTICAST ||
 	    (!(idev->dev->flags & IFF_LOOPBACK) &&
@@ -981,7 +1019,7 @@
 		goto out;
 	}
 
-	rt = addrconf_dst_alloc(idev, addr, false);
+	rt = addrconf_dst_alloc(idev, addr, pvd, false, caller);
 	if (IS_ERR(rt)) {
 		err = PTR_ERR(rt);
 		goto out;
@@ -1003,6 +1041,12 @@
 	ifa->prefered_lft = prefered_lft;
 	ifa->cstamp = ifa->tstamp = jiffies;
 	ifa->tokenized = false;
+	/*
+	 * ifp->pvd == NULL before the call (kzalloc)
+	 */
+#ifdef	CONFIG_NETPVD
+	pvd_migrate_addr(pvd, ifa);
+#endif
 
 	ifa->rt = rt;
 
@@ -1027,6 +1071,7 @@
 	}
 
 	in6_ifa_hold(ifa);
+
 	write_unlock(&idev->lock);
 out2:
 	rcu_read_unlock_bh();
@@ -1288,7 +1333,9 @@
 
 	ift = ipv6_add_addr(idev, &addr, NULL, tmp_plen,
 			    ipv6_addr_scope(&addr), addr_flags,
-			    tmp_valid_lft, tmp_prefered_lft);
+			    tmp_valid_lft, tmp_prefered_lft,
+			    ifp->pvd,
+			    __func__);	/* same pvd */
 	if (IS_ERR(ift)) {
 		in6_ifa_put(ifp);
 		in6_dev_put(idev);
@@ -1975,7 +2022,9 @@
 
 		ifp2 = ipv6_add_addr(idev, &new_addr, NULL, pfxlen,
 				     scope, flags, valid_lft,
-				     preferred_lft);
+				     preferred_lft,
+				     ifp->pvd,
+				     __func__);	/* same pvd */
 		if (IS_ERR(ifp2))
 			goto lock_errdad;
 
@@ -2216,7 +2265,8 @@
 
 static void
 addrconf_prefix_route(struct in6_addr *pfx, int plen, struct net_device *dev,
-		      unsigned long expires, u32 flags)
+		      unsigned long expires, u32 flags,
+		      void *pvd)
 {
 	struct fib6_config cfg = {
 		.fc_table = l3mdev_fib_table(dev) ? : RT6_TABLE_PREFIX,
@@ -2230,6 +2280,9 @@
 	};
 
 	cfg.fc_dst = *pfx;
+#ifdef	CONFIG_NETPVD
+	cfg.fc_pvd = pvd;
+#endif
 
 	/* Prevent useless cloning on PtP SIT.
 	   This thing is done here expecting that the whole
@@ -2240,7 +2293,7 @@
 		cfg.fc_flags |= RTF_NONEXTHOP;
 #endif
 
-	ip6_route_add(&cfg);
+	ip6_route_add(&cfg, __func__);
 }
 
 
@@ -2282,7 +2335,7 @@
 
 /* Create "default" multicast route to the interface */
 
-static void addrconf_add_mroute(struct net_device *dev)
+static void addrconf_add_mroute(struct net_device *dev, void *pvd)
 {
 	struct fib6_config cfg = {
 		.fc_table = l3mdev_fib_table(dev) ? : RT6_TABLE_LOCAL,
@@ -2294,11 +2347,14 @@
 	};
 
 	ipv6_addr_set(&cfg.fc_dst, htonl(0xFF000000), 0, 0, 0);
+#ifdef	CONFIG_NETPVD
+	cfg.fc_pvd = pvd;
+#endif
 
-	ip6_route_add(&cfg);
+	ip6_route_add(&cfg, __func__);
 }
 
-static struct inet6_dev *addrconf_add_dev(struct net_device *dev)
+static struct inet6_dev *addrconf_add_dev(struct net_device *dev, void *pvd)
 {
 	struct inet6_dev *idev;
 
@@ -2313,7 +2369,7 @@
 
 	/* Add default multicast route */
 	if (!(dev->flags & IFF_LOOPBACK) && !netif_is_l3_master(dev))
-		addrconf_add_mroute(dev);
+		addrconf_add_mroute(dev, pvd);
 
 	return idev;
 }
@@ -2396,7 +2452,8 @@
 				 struct inet6_dev *in6_dev,
 				 const struct in6_addr *addr, int addr_type,
 				 u32 addr_flags, bool sllao, bool tokenized,
-				 __u32 valid_lft, u32 prefered_lft)
+				 __u32 valid_lft, u32 prefered_lft,
+				 void *pvd)
 {
 	struct inet6_ifaddr *ifp = ipv6_get_ifaddr(net, addr, dev, 1);
 	int create = 0, update_lft = 0;
@@ -2419,7 +2476,9 @@
 					    pinfo->prefix_len,
 					    addr_type&IPV6_ADDR_SCOPE_MASK,
 					    addr_flags, valid_lft,
-					    prefered_lft);
+					    prefered_lft,
+					    pvd,
+					    __func__);	/* pvd will be updated below */
 
 		if (IS_ERR_OR_NULL(ifp))
 			return -1;
@@ -2439,6 +2498,11 @@
 		unsigned long now;
 		u32 stored_lft;
 
+		/* update PvD if needed */
+#ifdef	CONFIG_NETPVD
+		pvd_migrate_addr(pvd, ifp);
+#endif
+
 		/* update lifetime (RFC2462 5.5.3 e) */
 		spin_lock_bh(&ifp->lock);
 		now = jiffies;
@@ -2488,7 +2552,7 @@
 }
 EXPORT_SYMBOL_GPL(addrconf_prefix_rcv_add_addr);
 
-void addrconf_prefix_rcv(struct net_device *dev, u8 *opt, int len, bool sllao)
+void addrconf_prefix_rcv(struct net_device *dev, u8 *opt, int len, bool sllao, void *pvd)
 {
 	struct prefix_info *pinfo;
 	__u32 valid_lft;
@@ -2500,6 +2564,23 @@
 
 	pinfo = (struct prefix_info *) opt;
 
+	/* T.DANIS */
+	{
+		char sAddr[64];
+
+		printk("addrconf_prefix_rcv(pvd = %s, %s/%d, %s)\n",
+#ifdef	CONFIG_NETPVD
+			pvd ? ((struct net_pvd *) pvd)->name : "<no pvd>",
+#else
+			"<no pvd>",
+#endif
+			addrtostr(&pinfo->prefix, sAddr), pinfo->prefix_len,
+			dev->name
+			);
+	}
+	/* ! T.DANIS */
+
+
 	if (len < sizeof(struct prefix_info)) {
 		ADBG("addrconf: prefix option too short\n");
 		return;
@@ -2570,6 +2651,9 @@
 			} else {
 				rt6_clean_expires(rt);
 			}
+#ifdef	CONFIG_NETPVD
+			pvd_migrate_route(pvd, rt, __func__);
+#endif
 		} else if (valid_lft) {
 			clock_t expires = 0;
 			int flags = RTF_ADDRCONF | RTF_PREFIX_RT;
@@ -2579,7 +2663,8 @@
 				expires = jiffies_to_clock_t(rt_expires);
 			}
 			addrconf_prefix_route(&pinfo->prefix, pinfo->prefix_len,
-					      dev, expires, flags);
+					      dev, expires, flags,
+					      pvd);
 		}
 		ip6_rt_put(rt);
 	}
@@ -2621,10 +2706,13 @@
 						   &addr, addr_type,
 						   addr_flags, sllao,
 						   tokenized, valid_lft,
-						   prefered_lft);
+						   prefered_lft,
+						   pvd);
 		if (err)
 			goto put;
 
+		printk("dev_addr_generated (%s)\n", dev_addr_generated ? "true" : "false");
+
 		/* Ignore error case here because previous prefix add addr was
 		 * successful which will be notified.
 		 */
@@ -2632,9 +2720,26 @@
 					      addr_type, addr_flags, sllao,
 					      tokenized, valid_lft,
 					      prefered_lft,
-					      dev_addr_generated);
+					      dev_addr_generated,
+					      pvd);
 	}
 	inet6_prefix_notify(RTM_NEWPREFIX, in6_dev, pinfo);
+
+	/* T.DANIS */
+	{
+		char sAddr[64];
+
+		printk("inet6_prefix_notify(RTM_NEWPREFIX) called (%s/%d) [%s]\n",
+			addrtostr(&pinfo->prefix, sAddr), pinfo->prefix_len,
+#ifdef	CONFIG_NETPVD
+			pvd ? ((struct net_pvd *) pvd)->name : "<no pvd>"
+#else
+			"<no pvd>"
+#endif
+			);
+	}
+	/* ! T.DANIS */
+
 put:
 	in6_dev_put(in6_dev);
 }
@@ -2729,7 +2834,8 @@
 			  const struct in6_addr *pfx,
 			  const struct in6_addr *peer_pfx,
 			  unsigned int plen, __u32 ifa_flags,
-			  __u32 prefered_lft, __u32 valid_lft)
+			  __u32 prefered_lft, __u32 valid_lft,
+			  void *pvd)
 {
 	struct inet6_ifaddr *ifp;
 	struct inet6_dev *idev;
@@ -2755,7 +2861,7 @@
 	if (!dev)
 		return -ENODEV;
 
-	idev = addrconf_add_dev(dev);
+	idev = addrconf_add_dev(dev, pvd);
 	if (IS_ERR(idev))
 		return PTR_ERR(idev);
 
@@ -2788,12 +2894,15 @@
 	}
 
 	ifp = ipv6_add_addr(idev, pfx, peer_pfx, plen, scope, ifa_flags,
-			    valid_lft, prefered_lft);
+			    valid_lft, prefered_lft,
+			    pvd,
+			    __func__);
 
 	if (!IS_ERR(ifp)) {
 		if (!(ifa_flags & IFA_F_NOPREFIXROUTE)) {
 			addrconf_prefix_route(&ifp->addr, ifp->prefix_len, dev,
-					      expires, flags);
+					      expires, flags,
+					      pvd);
 		}
 
 		/*
@@ -2873,7 +2982,8 @@
 	rtnl_lock();
 	err = inet6_addr_add(net, ireq.ifr6_ifindex, &ireq.ifr6_addr, NULL,
 			     ireq.ifr6_prefixlen, IFA_F_PERMANENT,
-			     INFINITY_LIFE_TIME, INFINITY_LIFE_TIME);
+			     INFINITY_LIFE_TIME, INFINITY_LIFE_TIME,
+			     NULL);	/* FIXME : extend struct in6_ifreq to add a pvd field */
 	rtnl_unlock();
 	return err;
 }
@@ -2897,13 +3007,16 @@
 }
 
 static void add_addr(struct inet6_dev *idev, const struct in6_addr *addr,
-		     int plen, int scope)
+		     int plen, int scope,
+		     void *pvd)
 {
 	struct inet6_ifaddr *ifp;
 
 	ifp = ipv6_add_addr(idev, addr, NULL, plen,
 			    scope, IFA_F_PERMANENT,
-			    INFINITY_LIFE_TIME, INFINITY_LIFE_TIME);
+			    INFINITY_LIFE_TIME, INFINITY_LIFE_TIME,
+			    pvd,
+			    __func__);
 	if (!IS_ERR(ifp)) {
 		spin_lock_bh(&ifp->lock);
 		ifp->flags &= ~IFA_F_TENTATIVE;
@@ -2939,8 +3052,8 @@
 	}
 
 	if (addr.s6_addr32[3]) {
-		add_addr(idev, &addr, plen, scope);
-		addrconf_prefix_route(&addr, plen, idev->dev, 0, pflags);
+		add_addr(idev, &addr, plen, scope, NULL);	/* FIXME : pvd = NULL for now */
+		addrconf_prefix_route(&addr, plen, idev->dev, 0, pflags, NULL);
 		return;
 	}
 
@@ -2963,9 +3076,10 @@
 					flag |= IFA_HOST;
 				}
 
-				add_addr(idev, &addr, plen, flag);
+				add_addr(idev, &addr, plen, flag, NULL);	/* FIXME : for now */
 				addrconf_prefix_route(&addr, plen, idev->dev, 0,
-						      pflags);
+						      pflags,
+						      NULL);	/* pvd = NULL for now */
 			}
 		}
 	}
@@ -2989,7 +3103,7 @@
 		return;
 	}
 
-	add_addr(idev, &in6addr_loopback, 128, IFA_HOST);
+	add_addr(idev, &in6addr_loopback, 128, IFA_HOST, NULL);
 
 	/* Add routes to other interface's IPv6 addresses */
 	for_each_netdev(dev_net(dev), sp_dev) {
@@ -3019,7 +3133,7 @@
 				}
 			}
 
-			sp_rt = addrconf_dst_alloc(idev, &sp_ifa->addr, false);
+			sp_rt = addrconf_dst_alloc(idev, &sp_ifa->addr, sp_ifa->pvd, false, __func__);
 
 			/* Failure cases are ignored */
 			if (!IS_ERR(sp_rt)) {
@@ -3032,7 +3146,8 @@
 }
 
 void addrconf_add_linklocal(struct inet6_dev *idev,
-			    const struct in6_addr *addr, u32 flags)
+			    const struct in6_addr *addr, u32 flags,
+			    void *pvd)
 {
 	struct inet6_ifaddr *ifp;
 	u32 addr_flags = flags | IFA_F_PERMANENT;
@@ -3044,9 +3159,11 @@
 #endif
 
 	ifp = ipv6_add_addr(idev, addr, NULL, 64, IFA_LINK, addr_flags,
-			    INFINITY_LIFE_TIME, INFINITY_LIFE_TIME);
+			    INFINITY_LIFE_TIME, INFINITY_LIFE_TIME,
+			    pvd,
+			    __func__);
 	if (!IS_ERR(ifp)) {
-		addrconf_prefix_route(&ifp->addr, ifp->prefix_len, idev->dev, 0, 0);
+		addrconf_prefix_route(&ifp->addr, ifp->prefix_len, idev->dev, 0, 0, pvd);
 		addrconf_dad_start(ifp);
 		in6_ifa_put(ifp);
 	}
@@ -3142,7 +3259,7 @@
 	s->initialized = true;
 }
 
-static void addrconf_addr_gen(struct inet6_dev *idev, bool prefix_route)
+static void addrconf_addr_gen(struct inet6_dev *idev, bool prefix_route, void *pvd)
 {
 	struct in6_addr addr;
 
@@ -3159,9 +3276,10 @@
 	case IN6_ADDR_GEN_MODE_STABLE_PRIVACY:
 		if (!ipv6_generate_stable_address(&addr, 0, idev))
 			addrconf_add_linklocal(idev, &addr,
-					       IFA_F_STABLE_PRIVACY);
+					       IFA_F_STABLE_PRIVACY,
+					       pvd);
 		else if (prefix_route)
-			addrconf_prefix_route(&addr, 64, idev->dev, 0, 0);
+			addrconf_prefix_route(&addr, 64, idev->dev, 0, 0, pvd);
 		break;
 	case IN6_ADDR_GEN_MODE_EUI64:
 		/* addrconf_add_linklocal also adds a prefix_route and we
@@ -3169,9 +3287,9 @@
 		 * couldn't generate one.
 		 */
 		if (ipv6_generate_eui64(addr.s6_addr + 8, idev->dev) == 0)
-			addrconf_add_linklocal(idev, &addr, 0);
+			addrconf_add_linklocal(idev, &addr, 0, pvd);
 		else if (prefix_route)
-			addrconf_prefix_route(&addr, 64, idev->dev, 0, 0);
+			addrconf_prefix_route(&addr, 64, idev->dev, 0, 0, pvd);
 		break;
 	case IN6_ADDR_GEN_MODE_NONE:
 	default:
@@ -3198,7 +3316,7 @@
 		return;
 	}
 
-	idev = addrconf_add_dev(dev);
+	idev = addrconf_add_dev(dev, NULL);
 	if (IS_ERR(idev))
 		return;
 
@@ -3207,7 +3325,7 @@
 	    idev->addr_gen_mode == IN6_ADDR_GEN_MODE_EUI64)
 		idev->addr_gen_mode = IN6_ADDR_GEN_MODE_RANDOM;
 
-	addrconf_addr_gen(idev, false);
+	addrconf_addr_gen(idev, false, NULL);
 }
 
 #if IS_ENABLED(CONFIG_IPV6_SIT)
@@ -3230,14 +3348,14 @@
 	}
 
 	if (dev->priv_flags & IFF_ISATAP) {
-		addrconf_addr_gen(idev, false);
+		addrconf_addr_gen(idev, false, NULL);
 		return;
 	}
 
 	sit_add_v4_addrs(idev);
 
 	if (dev->flags&IFF_POINTOPOINT)
-		addrconf_add_mroute(dev);
+		addrconf_add_mroute(dev, NULL);
 }
 #endif
 
@@ -3254,9 +3372,9 @@
 		return;
 	}
 
-	addrconf_addr_gen(idev, true);
+	addrconf_addr_gen(idev, true, NULL);
 	if (dev->flags & IFF_POINTOPOINT)
-		addrconf_add_mroute(dev);
+		addrconf_add_mroute(dev, NULL);
 }
 #endif
 
@@ -3270,7 +3388,7 @@
 	if (!ifp->rt || !atomic_read(&ifp->rt->rt6i_ref)) {
 		struct rt6_info *rt, *prev;
 
-		rt = addrconf_dst_alloc(idev, &ifp->addr, false);
+		rt = addrconf_dst_alloc(idev, &ifp->addr, ifp->pvd, false, __func__);
 		if (unlikely(IS_ERR(rt)))
 			return PTR_ERR(rt);
 
@@ -3285,7 +3403,8 @@
 
 	if (!(ifp->flags & IFA_F_NOPREFIXROUTE)) {
 		addrconf_prefix_route(&ifp->addr, ifp->prefix_len,
-				      idev->dev, 0, 0);
+				      idev->dev, 0, 0,
+				      ifp->pvd);
 	}
 
 	if (ifp->state == INET6_IFADDR_STATE_PREDAD)
@@ -4146,13 +4265,24 @@
 static int if6_seq_show(struct seq_file *seq, void *v)
 {
 	struct inet6_ifaddr *ifp = (struct inet6_ifaddr *)v;
-	seq_printf(seq, "%pi6 %02x %02x %02x %02x %8s\n",
+	seq_printf(seq,
+#ifdef CONFIG_NETPVD
+		ifp->pvd ?
+			"%pi6 %02x %02x %02x %02x %8s / %s\n" :
+			"%pi6 %02x %02x %02x %02x %8s\n",
+#else
+		"%pi6 %02x %02x %02x %02x %8s\n",
+#endif
 		   &ifp->addr,
 		   ifp->idev->dev->ifindex,
 		   ifp->prefix_len,
 		   ifp->scope,
 		   (u8) ifp->flags,
-		   ifp->idev->dev->name);
+		   ifp->idev->dev->name
+#ifdef CONFIG_NETPVD
+		   , ifp->pvd ? ((struct net_pvd *) ifp->pvd)->name : ""
+#endif
+		   );
 	return 0;
 }
 
@@ -4414,7 +4544,8 @@
 }
 
 static int inet6_addr_modify(struct inet6_ifaddr *ifp, u32 ifa_flags,
-			     u32 prefered_lft, u32 valid_lft)
+			     u32 prefered_lft, u32 valid_lft,
+			     void *pvd)
 {
 	u32 flags;
 	clock_t expires;
@@ -4461,13 +4592,17 @@
 	ifp->valid_lft = valid_lft;
 	ifp->prefered_lft = prefered_lft;
 
+#ifdef	CONFIG_NETPVD
+	pvd_migrate_addr(pvd, ifp);
+#endif
+
 	spin_unlock_bh(&ifp->lock);
 	if (!(ifp->flags&IFA_F_TENTATIVE))
 		ipv6_ifa_notify(0, ifp);
 
 	if (!(ifa_flags & IFA_F_NOPREFIXROUTE)) {
 		addrconf_prefix_route(&ifp->addr, ifp->prefix_len, ifp->idev->dev,
-				      expires, flags);
+				      expires, flags, ifp->pvd);
 	} else if (had_prefixroute) {
 		enum cleanup_prefix_rt_t action;
 		unsigned long rt_expires;
@@ -4506,6 +4641,7 @@
 	u32 valid_lft = INFINITY_LIFE_TIME, preferred_lft = INFINITY_LIFE_TIME;
 	u32 ifa_flags;
 	int err;
+	void *pvd = NULL;	/* FIXME : check how to carry pvd in nlmsg */
 
 	err = nlmsg_parse(nlh, sizeof(*ifm), tb, IFA_MAX, ifa_ipv6_policy);
 	if (err < 0)
@@ -4527,6 +4663,25 @@
 		valid_lft = INFINITY_LIFE_TIME;
 	}
 
+#ifdef	CONFIG_NETPVD
+	if (tb[IFA_PVD]) {
+		printk("IFA_PVD : len = %d\n", nla_len(tb[IFA_PVD]));
+
+		if (nla_len(tb[IFA_PVD]) > PVDNAMSIZ) {
+			return -EINVAL;
+		}
+		if (nla_len(tb[IFA_PVD]) == 0) {
+			pvd = NULL;
+		} else
+		if ((pvd = pvd_get_by_name(
+					sock_net(skb->sk),
+					nla_data(tb[IFA_PVD]),
+					NULL, NULL)) == NULL) {
+			return -ESRCH;
+		}
+	}
+#endif
+
 	dev =  __dev_get_by_index(net, ifm->ifa_index);
 	if (!dev)
 		return -ENODEV;
@@ -4545,14 +4700,15 @@
 		 */
 		return inet6_addr_add(net, ifm->ifa_index, pfx, peer_pfx,
 				      ifm->ifa_prefixlen, ifa_flags,
-				      preferred_lft, valid_lft);
+				      preferred_lft, valid_lft,
+				      pvd);
 	}
 
 	if (nlh->nlmsg_flags & NLM_F_EXCL ||
 	    !(nlh->nlmsg_flags & NLM_F_REPLACE))
 		err = -EEXIST;
 	else
-		err = inet6_addr_modify(ifa, ifa_flags, preferred_lft, valid_lft);
+		err = inet6_addr_modify(ifa, ifa_flags, preferred_lft, valid_lft, pvd);
 
 	in6_ifa_put(ifa);
 
@@ -4655,6 +4811,21 @@
 	if (nla_put_u32(skb, IFA_FLAGS, ifa->flags) < 0)
 		goto error;
 
+#ifdef	CONFIG_NETPVD
+	if (ifa->pvd) {
+		struct net_pvd *pvd = ifa->pvd;
+		char *pvdname = pvd->name;
+
+		if (! pvd->implicit_flag) {
+			printk("Addr associated to pvd %s\n", pvdname);
+
+			if (nla_put(skb, IFA_PVD, strlen(pvdname) + 1, pvdname))
+				goto error;
+
+			printk("IFA_PVD pushed on skb\n");
+		}
+	}
+#endif
 	nlmsg_end(skb, nlh);
 	return 0;
 
@@ -5473,7 +5644,8 @@
 			addrconf_join_anycast(ifp);
 		if (!ipv6_addr_any(&ifp->peer_addr))
 			addrconf_prefix_route(&ifp->peer_addr, 128,
-					      ifp->idev->dev, 0, 0);
+					      ifp->idev->dev, 0, 0,
+					      ifp->pvd);
 		break;
 	case RTM_DELADDR:
 		if (ifp->idev->cnf.forwarding)
@@ -5483,7 +5655,8 @@
 			struct rt6_info *rt;
 
 			rt = addrconf_get_prefix_route(&ifp->peer_addr, 128,
-						       ifp->idev->dev, 0, 0);
+						       ifp->idev->dev,
+						       0, 0);
 			if (rt)
 				ip6_del_rt(rt);
 		}
diff -Naur -X DiffNaurExclude ubuntu-4.10.0-orig/net/ipv6/anycast.c ubuntu-4.10.0/net/ipv6/anycast.c
--- ubuntu-4.10.0-orig/net/ipv6/anycast.c	2017-08-10 11:05:24.289046482 +0100
+++ ubuntu-4.10.0/net/ipv6/anycast.c	2017-07-18 14:25:07.415522851 +0100
@@ -262,7 +262,7 @@
 		}
 	}
 
-	rt = addrconf_dst_alloc(idev, addr, true);
+	rt = addrconf_dst_alloc(idev, addr, NULL, true, __func__);	/* FIXME : pvd == NULL for now */
 	if (IS_ERR(rt)) {
 		err = PTR_ERR(rt);
 		goto out;
diff -Naur -X DiffNaurExclude ubuntu-4.10.0-orig/net/ipv6/ip6_fib.c ubuntu-4.10.0/net/ipv6/ip6_fib.c
--- ubuntu-4.10.0-orig/net/ipv6/ip6_fib.c	2017-08-10 11:05:24.289046482 +0100
+++ ubuntu-4.10.0/net/ipv6/ip6_fib.c	2017-07-18 14:25:07.415522851 +0100
@@ -37,6 +37,10 @@
 #include <net/ip6_fib.h>
 #include <net/ip6_route.h>
 
+#ifdef CONFIG_NETPVD
+#include <net/pvd.h>
+#endif
+
 #define RT6_DEBUG 2
 
 #if RT6_DEBUG >= 3
@@ -1960,10 +1964,21 @@
 	else
 		seq_puts(seq, "00000000000000000000000000000000");
 
-	seq_printf(seq, " %08x %08x %08x %08x %8s\n",
+	seq_printf(seq,
+#ifdef CONFIG_NETPVD
+		rt->rt6i_pvd ?
+			" %08x %08x %08x %08x %8s / %s\n" :
+			" %08x %08x %08x %08x %8s%s\n",
+#else
+		" %08x %08x %08x %08x %8s\n",
+#endif
 		   rt->rt6i_metric, atomic_read(&rt->dst.__refcnt),
 		   rt->dst.__use, rt->rt6i_flags,
-		   rt->dst.dev ? rt->dst.dev->name : "");
+		   rt->dst.dev ? rt->dst.dev->name : ""
+#ifdef CONFIG_NETPVD
+		   , rt->rt6i_pvd ? ((struct net_pvd *) rt->rt6i_pvd)->name : ""
+#endif
+		   );
 	iter->w.leaf = NULL;
 	return 0;
 }
diff -Naur -X DiffNaurExclude ubuntu-4.10.0-orig/net/ipv6/ndisc.c ubuntu-4.10.0/net/ipv6/ndisc.c
--- ubuntu-4.10.0-orig/net/ipv6/ndisc.c	2017-08-10 11:05:24.293046482 +0100
+++ ubuntu-4.10.0/net/ipv6/ndisc.c	2017-08-28 17:22:03.652156485 +0100
@@ -44,6 +44,9 @@
 #ifdef CONFIG_SYSCTL
 #include <linux/sysctl.h>
 #endif
+#ifdef	CONFIG_NETPVD
+#include <net/pvd.h>
+#endif
 
 #include <linux/if_addr.h>
 #include <linux/if_arp.h>
@@ -61,6 +64,10 @@
 #include <net/addrconf.h>
 #include <net/icmp.h>
 
+#ifdef	CONFIG_NETPVD
+#include <net/pvd.h>
+#endif
+
 #include <net/netlink.h>
 #include <linux/rtnetlink.h>
 
@@ -140,6 +147,21 @@
 };
 EXPORT_SYMBOL_GPL(nd_tbl);
 
+static char *addrtostr(struct in6_addr const *addr, char *str)
+{
+	sprintf(str,
+		"%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x",
+		addr->s6_addr[0], addr->s6_addr[1],
+		addr->s6_addr[2], addr->s6_addr[3],
+		addr->s6_addr[4], addr->s6_addr[5],
+		addr->s6_addr[6], addr->s6_addr[7],
+		addr->s6_addr[8], addr->s6_addr[9],
+		addr->s6_addr[10], addr->s6_addr[11],
+		addr->s6_addr[12], addr->s6_addr[13],
+		addr->s6_addr[14], addr->s6_addr[15]);
+	return(str);
+}
+
 void __ndisc_fill_addr_option(struct sk_buff *skb, int type, void *data,
 			      int data_len, int pad)
 {
@@ -211,6 +233,50 @@
 	return cur <= end && ndisc_is_useropt(dev, cur) ? cur : NULL;
 }
 
+#ifdef	CONFIG_NETPVD
+static int pvdid_parse_opt(
+		struct nd_opt_hdr *nd_opt,
+		struct ndisc_options *ndopts)
+{
+	int l = nd_opt->nd_opt_len << 3;
+	int pvdname_len = l - sizeof(struct nd_opt_pvdid);
+	struct nd_opt_pvdid *pvd = (struct nd_opt_pvdid *) nd_opt;
+
+	printk("pvdid_parse_opt called\n");
+
+	if (l < sizeof(struct nd_opt_pvdid)) {
+		printk("Invalid nd_opt_pvdid size (%d, expected at least %d)\n",
+			l,
+			(int) sizeof(struct nd_opt_pvdid));
+		return -1;
+	}
+
+	if (pvdname_len > PVDNAMSIZ || pvdname_len < 1) {
+		printk("Invalid length for pvd name in option (%d, max %d)\n",
+			pvdname_len, PVDNAMSIZ);
+		return -1;
+	}
+
+	if (pvdname_len == PVDNAMSIZ &&
+			pvd->nd_opt_pvdid_name[PVDNAMSIZ - 1] != '\0') {
+		printk("Pvd name too long in option\n");
+		return -1;
+	}
+
+	memset(ndopts->pvdname, 0, sizeof(ndopts->pvdname));
+
+	strncpy(ndopts->pvdname, (char *) pvd->nd_opt_pvdid_name, pvdname_len);
+
+	ndopts->pvd_h_flag = (ntohs(pvd->nd_opt_pvdid_flags) >> 15) & 0x01;
+	ndopts->pvd_l_flag = (ntohs(pvd->nd_opt_pvdid_flags) >> 14) & 0x01;
+	ndopts->pvd_sequence_number = ntohs(pvd->nd_opt_pvdid_sequence_number);
+
+	printk("Correct nd_opt_pvdid option (%s)\n", ndopts->pvdname);
+
+	return 0;
+}
+#endif
+
 struct ndisc_options *ndisc_parse_options(const struct net_device *dev,
 					  u8 *opt, int opt_len,
 					  struct ndisc_options *ndopts)
@@ -255,6 +321,19 @@
 				ndopts->nd_opts_ri = nd_opt;
 			break;
 #endif
+#ifdef	CONFIG_NETPVD
+		case ND_OPT_PVDID:
+			printk("ND_OPT_PVDID option found in RA\n");
+			if (ndopts->nd_opt_pvdid) {
+				ND_PRINTK(2, warn,
+					"%s: duplicated PVD option found. Ignored\n",
+					__func__);
+			} else
+			if (pvdid_parse_opt(nd_opt, ndopts) == 0) {
+				ndopts->nd_opt_pvdid = nd_opt;
+			}
+			break;
+#endif
 		default:
 			if (ndisc_is_useropt(dev, nd_opt)) {
 				ndopts->nd_useropts_end = nd_opt;
@@ -1149,9 +1228,17 @@
 	unsigned int pref = 0;
 	__u32 old_if_flags;
 	bool send_ifinfo_notify = false;
+	int ra_len = skb_tail_pointer(skb) - skb_transport_header(skb);
+#ifdef	CONFIG_NETPVD
+	struct net_pvd *pvd = NULL;
+#else
+	void *pvd = NULL;
+#endif
 
 	__u8 *opt = (__u8 *)(ra_msg + 1);
 
+	printk("ndisc_router_discovery : ra_len = %d\n", ra_len);
+
 	optlen = (skb_tail_pointer(skb) - skb_transport_header(skb)) -
 		sizeof(struct ra_msg);
 
@@ -1190,6 +1277,55 @@
 		return;
 	}
 
+#ifdef	CONFIG_NETPVD
+	/*
+	 * We want to link all RA options to their PvD, if
+	 * specified. We create the net_pvd structure now,
+	 * and will use it when needed
+	 * For now, items of interest are :
+	 * + the user options (such as rdnss and dnssl)
+	 * + the router's lla
+	 * + the advertised prefixes
+	 * + the incoming device (skb->dev)
+	 * + and of course the pvd name
+	 */
+	printk("Checking nd_opt_pvdid options\n");
+	if (ndopts.nd_opt_pvdid) {
+		printk("Some nd_opt_pvdid options\n");
+		if ((pvd = register_pvd(
+				dev_net(skb->dev),
+				ndopts.pvdname,
+				skb->dev,
+				&ipv6_hdr(skb)->saddr)) == NULL) {
+			ND_PRINTK(0, err, "RA: can't allocate pvd %s\n",
+				 ndopts.pvdname);
+			return;
+		}
+		pvd->notifications_blocked = true;
+
+		/*
+		 * Fill in the rest of parameters. We only keep here
+		 * the fields that the kernel can use. Other associated
+		 * values, such as DNSSL/RDNSS, will be caught via the
+		 * netlink notifications by the user land applications.
+		 */
+		pvd->h_flag = ndopts.pvd_h_flag;
+		pvd->l_flag = ndopts.pvd_l_flag;
+		pvd->sequence_number = ndopts.pvd_sequence_number;
+	}
+	else {
+		printk("No nd_opt_pvdid options. Creating implicit pvd\n");
+		if ((pvd = register_pvd(
+				dev_net(skb->dev),
+				NULL,
+				skb->dev,
+				&ipv6_hdr(skb)->saddr)) == NULL) {
+			ND_PRINTK(0, err, "RA: can't allocate implicit pvd\n");
+			return;
+		}
+	}
+#endif
+
 	if (!ipv6_accept_ra(in6_dev)) {
 		ND_PRINTK(2, info,
 			  "RA: %s, did not accept ra for dev: %s\n",
@@ -1261,6 +1397,8 @@
 
 	rt = rt6_get_dflt_router(&ipv6_hdr(skb)->saddr, skb->dev);
 
+	printk("ndisc_router_discovery : rt6_get_dflt_router => rt = %p\n", rt);
+
 	if (rt) {
 		neigh = dst_neigh_lookup(&rt->dst, &ipv6_hdr(skb)->saddr);
 		if (!neigh) {
@@ -1268,7 +1406,7 @@
 				  "RA: %s got default router without neighbour\n",
 				  __func__);
 			ip6_rt_put(rt);
-			return;
+			goto out_pvd;
 		}
 	}
 	if (rt && lifetime == 0) {
@@ -1282,11 +1420,14 @@
 		ND_PRINTK(3, info, "RA: adding default router\n");
 
 		rt = rt6_add_dflt_router(&ipv6_hdr(skb)->saddr, skb->dev, pref);
+
+		printk("ndisc_router_discovery : rt6_add_dflt_router => rt = %p\n", rt);
+
 		if (!rt) {
 			ND_PRINTK(0, err,
 				  "RA: %s failed to add default route\n",
 				  __func__);
-			return;
+			goto out_pvd;
 		}
 
 		neigh = dst_neigh_lookup(&rt->dst, &ipv6_hdr(skb)->saddr);
@@ -1295,13 +1436,21 @@
 				  "RA: %s got default router without neighbour\n",
 				  __func__);
 			ip6_rt_put(rt);
-			return;
+			goto out_pvd;
 		}
 		neigh->flags |= NTF_ROUTER;
 	} else if (rt) {
 		rt->rt6i_flags = (rt->rt6i_flags & ~RTF_PREF_MASK) | RTF_PREF(pref);
 	}
 
+#ifdef	CONFIG_NETPVD
+	/*
+	 * Make sure this default route is linked to the pvd
+	 */
+	if (rt)
+		pvd_migrate_route(pvd, rt, __func__);
+#endif
+
 	if (rt)
 		rt6_set_expires(rt, jiffies + (HZ * lifetime));
 	if (in6_dev->cnf.accept_ra_min_hop_limit < 256 &&
@@ -1325,6 +1474,7 @@
 	if (in6_dev->nd_parms) {
 		unsigned long rtime = ntohl(ra_msg->retrans_timer);
 
+
 		if (rtime && rtime/1000 < MAX_SCHEDULE_TIMEOUT/HZ) {
 			rtime = (rtime*HZ)/1000;
 			if (rtime < HZ/10)
@@ -1410,6 +1560,13 @@
 		     p;
 		     p = ndisc_next_option(p, ndopts.nd_opts_ri_end)) {
 			struct route_info *ri = (struct route_info *)p;
+			/* T.DANIS */
+			if (ri->length == 3) {
+				char sAddr[64];
+				addrtostr((struct in6_addr *) ri->prefix, sAddr);
+				printk("route_info : %s\n", sAddr);
+			}
+			/* ! T.DANIS */
 #ifdef CONFIG_IPV6_NDISC_NODETYPE
 			if (skb->ndisc_nodetype == NDISC_NODETYPE_NODEFAULT &&
 			    ri->prefix_len == 0)
@@ -1421,7 +1578,8 @@
 			if (ri->prefix_len > in6_dev->cnf.accept_ra_rt_info_max_plen)
 				continue;
 			rt6_route_rcv(skb->dev, (u8 *)p, (p->nd_opt_len) << 3,
-				      &ipv6_hdr(skb)->saddr);
+				      &ipv6_hdr(skb)->saddr,
+				      pvd);
 		}
 	}
 
@@ -1445,7 +1603,8 @@
 		     p = ndisc_next_option(p, ndopts.nd_opts_pi_end)) {
 			addrconf_prefix_rcv(skb->dev, (u8 *)p,
 					    (p->nd_opt_len) << 3,
-					    ndopts.nd_opts_src_lladdr != NULL);
+					    ndopts.nd_opts_src_lladdr != NULL,
+					    pvd);
 		}
 	}
 
@@ -1481,10 +1640,55 @@
 	if (ndopts.nd_opts_tgt_lladdr || ndopts.nd_opts_rh) {
 		ND_PRINTK(2, warn, "RA: invalid RA options\n");
 	}
+
 out:
 	ip6_rt_put(rt);
 	if (neigh)
 		neigh_release(neigh);
+
+out_pvd :
+#ifdef	CONFIG_NETPVD
+	if (! pvd)
+		goto out_last;
+
+	/*
+	 * We want to catch RDNSS/DNSSL options to associate them
+	 * with a PvD if defined in the RA. If no PvD, no need
+	 * to parse them. For now, we only handle the lifetime and
+	 * do not bother to parse the option itself (especially the
+	 * names). The applications will retrieve the option and
+	 * will have to extract the DNSSL/RDNSS fields if they
+	 * want to)
+	 */
+	if (ndopts.nd_useropts) {
+		struct nd_opt_hdr *p;
+		for (p = ndopts.nd_useropts;
+		     p;
+		     p = ndisc_next_useropt(skb->dev, p,
+					    ndopts.nd_useropts_end)) {
+			if (p->nd_opt_type == ND_OPT_RDNSS) {
+				pvd_register_rdnss(pvd, p);
+			} else
+			if (p->nd_opt_type == ND_OPT_DNSSL) {
+				pvd_register_dnssl(pvd, p);
+			}
+		}
+	}
+
+	/*
+	 * rtnl notification must happen last because the application
+	 * could query the pvd attributes before we had a chance to
+	 * update them (unfortunately, this is not sufficient, because
+	 * routes and addresses creation above may have also issued
+	 * some notifications)
+	 */
+	pvd->notifications_blocked = false;
+
+	pvd_rtnl_notify(pvd, PVD_UPDATE);
+
+out_last :
+#endif
+	return;
 }
 
 static void ndisc_redirect_rcv(struct sk_buff *skb)
diff -Naur -X DiffNaurExclude ubuntu-4.10.0-orig/net/ipv6/route.c ubuntu-4.10.0/net/ipv6/route.c
--- ubuntu-4.10.0-orig/net/ipv6/route.c	2017-08-10 11:05:24.293046482 +0100
+++ ubuntu-4.10.0/net/ipv6/route.c	2017-07-31 09:21:41.712597096 +0100
@@ -118,6 +118,20 @@
 
 static DEFINE_PER_CPU_ALIGNED(struct uncached_list, rt6_uncached_list);
 
+static void addrtostr(struct in6_addr const *addr, char *str)
+{
+	sprintf(str,
+		"%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x",
+		addr->s6_addr[0], addr->s6_addr[1],
+		addr->s6_addr[2], addr->s6_addr[3],
+		addr->s6_addr[4], addr->s6_addr[5],
+		addr->s6_addr[6], addr->s6_addr[7],
+		addr->s6_addr[8], addr->s6_addr[9],
+		addr->s6_addr[10], addr->s6_addr[11],
+		addr->s6_addr[12], addr->s6_addr[13],
+		addr->s6_addr[14], addr->s6_addr[15]);
+}
+
 static void rt6_uncached_list_add(struct rt6_info *rt)
 {
 	struct uncached_list *ul = raw_cpu_ptr(&rt6_uncached_list);
@@ -385,6 +399,10 @@
 	}
 
 	dst->from = NULL;
+
+#ifdef	CONFIG_NETPVD
+	pvd_migrate_route(NULL, rt, __func__);
+#endif
 	dst_release(from);
 }
 
@@ -758,7 +776,8 @@
 
 #ifdef CONFIG_IPV6_ROUTE_INFO
 int rt6_route_rcv(struct net_device *dev, u8 *opt, int len,
-		  const struct in6_addr *gwaddr)
+		  const struct in6_addr *gwaddr,
+		  void *pvd)
 {
 	struct net *net = dev_net(dev);
 	struct route_info *rinfo = (struct route_info *) opt;
@@ -767,6 +786,16 @@
 	unsigned long lifetime;
 	struct rt6_info *rt;
 
+	/* T.DANIS */
+	printk("rt6_route_rcv called (pvd %s)\n",
+#ifdef CONFIG_NETPVD
+		pvd ? ((struct net_pvd *) pvd)->name : "<no pvd>"
+#else
+		"<no pvd>"
+#endif
+	      );
+	/* ! T.DANIS */
+
 	if (len < sizeof(struct route_info)) {
 		return -EINVAL;
 	}
@@ -802,6 +831,14 @@
 		prefix = &prefix_buf;
 	}
 
+	/* T.DANIS */
+	{
+		char sAddr[64];
+		addrtostr(prefix, sAddr);
+		printk("rt6_route_rcv : route = %s\n", sAddr);
+	}
+	/* ! T.DANIS */
+
 	if (rinfo->prefix_len == 0)
 		rt = rt6_get_dflt_router(gwaddr, dev);
 	else
@@ -820,6 +857,10 @@
 		rt->rt6i_flags = RTF_ROUTEINFO |
 				 (rt->rt6i_flags & ~RTF_PREF_MASK) | RTF_PREF(pref);
 
+#ifdef	CONFIG_NETPVD
+	pvd_migrate_route(pvd, rt, __func__);
+#endif
+
 	if (rt) {
 		if (!addrconf_finite_timeout(lifetime))
 			rt6_clean_expires(rt);
@@ -1210,6 +1251,12 @@
 	    (fl6->flowi6_oif && any_src))
 		flags |= RT6_LOOKUP_F_IFACE;
 
+#ifdef	CONFIG_NETPVD
+	if (sk && sk->sk_n_bound_pvd > 0) {
+		flags |= RT6_LOOKUP_F_PVD;
+	}
+#endif
+
 	if (!any_src)
 		flags |= RT6_LOOKUP_F_HAS_SADDR;
 	else if (sk)
@@ -1821,7 +1868,7 @@
 	return rt;
 }
 
-static struct rt6_info *ip6_route_info_create(struct fib6_config *cfg)
+static struct rt6_info *ip6_route_info_create(struct fib6_config *cfg, const char *caller)
 {
 	struct net *net = cfg->fc_nlinfo.nl_net;
 	struct rt6_info *rt = NULL;
@@ -2076,25 +2123,34 @@
 
 	cfg->fc_nlinfo.nl_net = dev_net(dev);
 
+#ifdef	CONFIG_NETPVD
+	pvd_migrate_route(cfg->fc_pvd, rt, caller);
+#endif
+
 	return rt;
 out:
 	if (dev)
 		dev_put(dev);
 	if (idev)
 		in6_dev_put(idev);
+
+#ifdef	CONFIG_NETPVD
+	pvd_migrate_route(NULL, rt, caller);	/* deassociate rt and its pvd */
+#endif
+
 	if (rt)
 		dst_free(&rt->dst);
 
 	return ERR_PTR(err);
 }
 
-int ip6_route_add(struct fib6_config *cfg)
+int ip6_route_add(struct fib6_config *cfg, const char *caller)
 {
 	struct mx6_config mxc = { .mx = NULL, };
 	struct rt6_info *rt;
 	int err;
 
-	rt = ip6_route_info_create(cfg);
+	rt = ip6_route_info_create(cfg, caller);
 	if (IS_ERR(rt)) {
 		err = PTR_ERR(rt);
 		rt = NULL;
@@ -2147,6 +2203,82 @@
 	return __ip6_del_rt(rt, &info);
 }
 
+#if	0
+#ifdef	CONFIG_NETPVD
+static void rtmsg_to_fib6_config(struct net *net,
+				 struct in6_rtmsg *rtmsg,
+				 struct fib6_config *cfg);
+int ip6_route_pvd_attach(
+		struct sock *sk,
+		char __user *optval,
+		int optlen)
+{
+	struct net *net = sock_net(sk);
+	struct fib6_config _cfg, *cfg = &_cfg;
+	struct in6_rt_pvdmsg rt_pvdmsg;
+	struct fib6_table *table;
+	struct fib6_node *fn;
+	struct rt6_info *rt;
+	int err = -ESRCH;
+	struct net_pvd *pvd;
+
+	if (! ns_capable(net->user_ns, CAP_NET_ADMIN))
+		return -EPERM;
+
+	if (optlen != sizeof(struct in6_rt_pvdmsg)) {
+		return -EINVAL;
+	}
+
+	if (copy_from_user(&rt_pvdmsg, optval, optlen)) {
+		return -EFAULT;
+	}
+
+	rtmsg_to_fib6_config(net, &rt_pvdmsg.rtmsg, cfg);
+
+	if (rt_pvdmsg.pvdname[0] == '\0') {
+		cfg->fc_pvd = NULL;
+	} else
+	if ((cfg->fc_pvd = pvd_get_by_name(net, rt_pvdmsg.pvdname, NULL, NULL)) == NULL)
+		return -ESRCH;
+
+	table = fib6_get_table(cfg->fc_nlinfo.nl_net, cfg->fc_table);
+	if (!table)
+		return err;
+
+	read_lock_bh(&table->tb6_lock);
+
+	fn = fib6_locate(&table->tb6_root,
+			 &cfg->fc_dst, cfg->fc_dst_len,
+			 &cfg->fc_src, cfg->fc_src_len);
+
+	if (fn) {
+		for (rt = fn->leaf; rt; rt = rt->dst.rt6_next) {
+			if ((rt->rt6i_flags & RTF_CACHE) &&
+			    !(cfg->fc_flags & RTF_CACHE))
+				continue;
+			if (cfg->fc_ifindex &&
+			    (!rt->dst.dev ||
+			     rt->dst.dev->ifindex != cfg->fc_ifindex))
+				continue;
+			if (cfg->fc_flags & RTF_GATEWAY &&
+			    !ipv6_addr_equal(&cfg->fc_gateway, &rt->rt6i_gateway))
+				continue;
+			if (cfg->fc_metric && cfg->fc_metric != rt->rt6i_metric)
+				continue;
+			if (cfg->fc_protocol && cfg->fc_protocol != rt->rt6i_protocol)
+				continue;
+			read_unlock_bh(&table->tb6_lock);
+
+			return pvd_migrate_route(pvd, rt, __func__) == 0 ? 0 : -EINVAL;
+		}
+	}
+	read_unlock_bh(&table->tb6_lock);
+
+	return err;
+}
+#endif		/* CONFIG_NETPVD */
+#endif
+
 static int ip6_route_del(struct fib6_config *cfg)
 {
 	struct fib6_table *table;
@@ -2399,18 +2531,23 @@
 	cfg.fc_table = l3mdev_fib_table(dev) ? : RT6_TABLE_INFO,
 	cfg.fc_dst = *prefix;
 	cfg.fc_gateway = *gwaddr;
+#ifdef	CONFIG_NETPVD
+	cfg.fc_pvd = NULL;
+#endif
 
 	/* We should treat it as a default route if prefix length is 0. */
 	if (!prefixlen)
 		cfg.fc_flags |= RTF_DEFAULT;
 
-	ip6_route_add(&cfg);
+	ip6_route_add(&cfg, __func__);
 
 	return rt6_get_route_info(net, prefix, prefixlen, gwaddr, dev);
 }
 #endif
 
-struct rt6_info *rt6_get_dflt_router(const struct in6_addr *addr, struct net_device *dev)
+struct rt6_info *rt6_get_dflt_router(
+			const struct in6_addr *addr,
+			struct net_device *dev)
 {
 	u32 tb_id = l3mdev_fib_table(dev) ? : RT6_TABLE_DFLT;
 	struct rt6_info *rt;
@@ -2430,6 +2567,7 @@
 	if (rt)
 		dst_hold(&rt->dst);
 	read_unlock_bh(&table->tb6_lock);
+
 	return rt;
 }
 
@@ -2449,8 +2587,11 @@
 	};
 
 	cfg.fc_gateway = *gwaddr;
+#ifdef	CONFIG_NETPVD
+	cfg.fc_pvd = NULL;
+#endif
 
-	if (!ip6_route_add(&cfg)) {
+	if (!ip6_route_add(&cfg, __func__)) {
 		struct fib6_table *table;
 
 		table = fib6_get_table(dev_net(dev), cfg.fc_table);
@@ -2543,7 +2684,7 @@
 		rtnl_lock();
 		switch (cmd) {
 		case SIOCADDRT:
-			err = ip6_route_add(&cfg);
+			err = ip6_route_add(&cfg, __func__);
 			break;
 		case SIOCDELRT:
 			err = ip6_route_del(&cfg);
@@ -2614,7 +2755,9 @@
 
 struct rt6_info *addrconf_dst_alloc(struct inet6_dev *idev,
 				    const struct in6_addr *addr,
-				    bool anycast)
+				    void *pvd,
+				    bool anycast,
+				    const char *caller)
 {
 	u32 tb_id;
 	struct net *net = dev_net(idev->dev);
@@ -2637,6 +2780,9 @@
 	rt->dst.input = ip6_input;
 	rt->dst.output = ip6_output;
 	rt->rt6i_idev = idev;
+#ifdef	CONFIG_NETPVD
+	pvd_migrate_route(pvd, rt, caller);
+#endif
 
 	rt->rt6i_flags = RTF_UP | RTF_NONEXTHOP;
 	if (anycast)
@@ -2926,6 +3072,29 @@
 			goto errout;
 	}
 
+#ifdef	CONFIG_NETPVD
+	if (tb[RTA_PVD]) {
+		printk("RTA_PVD : len = %d\n", nla_len(tb[RTA_PVD]));
+
+		if (nla_len(tb[RTA_PVD]) > PVDNAMSIZ) {
+			err = -EINVAL;
+			goto errout;
+		}
+		if (nla_len(tb[RTA_PVD]) == 0) {
+			cfg->fc_pvd = NULL;
+		} else
+		if ((cfg->fc_pvd = 
+				pvd_get_by_name(
+					sock_net(skb->sk),
+					nla_data(tb[RTA_PVD]),
+					NULL,
+					NULL)) == NULL) {
+			err = -ESRCH;
+			goto errout;
+		}
+	}
+#endif
+
 	if (tb[RTA_EXPIRES]) {
 		unsigned long timeout = addrconf_timeout_fixup(nla_get_u32(tb[RTA_EXPIRES]), HZ);
 
@@ -3032,7 +3201,7 @@
 				r_cfg.fc_encap_type = nla_get_u16(nla);
 		}
 
-		rt = ip6_route_info_create(&r_cfg);
+		rt = ip6_route_info_create(&r_cfg, __func__);
 		if (IS_ERR(rt)) {
 			err = PTR_ERR(rt);
 			rt = NULL;
@@ -3158,7 +3327,7 @@
 	if (cfg.fc_mp)
 		return ip6_route_multipath_add(&cfg);
 	else
-		return ip6_route_add(&cfg);
+		return ip6_route_add(&cfg, __func__);
 }
 
 static inline size_t rt6_nlmsg_size(struct rt6_info *rt)
@@ -3334,6 +3503,22 @@
 	if (lwtunnel_fill_encap(skb, rt->dst.lwtstate) < 0)
 		goto nla_put_failure;
 
+#ifdef	CONFIG_NETPVD
+	if (rt->rt6i_pvd) {
+		struct net_pvd *pvd = rt->rt6i_pvd;
+		char *pvdname = pvd->name;
+
+		if (! pvd->implicit_flag) {
+			printk("Route associated to pvd %s\n", pvdname);
+
+			if (nla_put(skb, RTA_PVD, strlen(pvdname) + 1, pvdname))
+				goto nla_put_failure;
+
+			printk("RTA_PVD pushed on skb\n");
+		}
+	}
+#endif
+
 	nlmsg_end(skb, nlh);
 	return 0;
 
diff -Naur -X DiffNaurExclude ubuntu-4.10.0-orig/security/selinux/nlmsgtab.c ubuntu-4.10.0/security/selinux/nlmsgtab.c
--- ubuntu-4.10.0-orig/security/selinux/nlmsgtab.c	2017-08-10 11:05:24.293046482 +0100
+++ ubuntu-4.10.0/security/selinux/nlmsgtab.c	2017-07-18 14:25:07.419522851 +0100
@@ -78,6 +78,8 @@
 	{ RTM_GETNSID,		NETLINK_ROUTE_SOCKET__NLMSG_READ  },
 	{ RTM_NEWSTATS,		NETLINK_ROUTE_SOCKET__NLMSG_READ },
 	{ RTM_GETSTATS,		NETLINK_ROUTE_SOCKET__NLMSG_READ  },
+
+	{ RTM_PVDSTATUS,	NETLINK_ROUTE_SOCKET__NLMSG_READ  },	/* PVD extension */
 };
 
 static struct nlmsg_perm nlmsg_tcpdiag_perms[] =
@@ -157,7 +159,8 @@
 	switch (sclass) {
 	case SECCLASS_NETLINK_ROUTE_SOCKET:
 		/* RTM_MAX always point to RTM_SETxxxx, ie RTM_NEWxxx + 3 */
-		BUILD_BUG_ON(RTM_MAX != (RTM_NEWSTATS + 3));
+		BUILD_BUG_ON(RTM_MAX != (RTM_PVDSTATUS + 3));	//  T.DANIS : used to be RTM_NEWSTATS + 3
+
 		err = nlmsg_perm(nlmsg_type, perm, nlmsg_route_perms,
 				 sizeof(nlmsg_route_perms));
 		break;
